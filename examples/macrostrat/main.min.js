var app = (function (exports) {
  'use strict';

  const refProperties = [
    'type', 
    'source', 
    'source-layer', 
    'minzoom', 
    'maxzoom', 
    'filter', 
    'layout'
  ];

  function derefLayers(layers) {
    // From mapbox-gl-js, style-spec/deref.js
    /**
     * Given an array of layers, some of which may contain `ref` properties
     * whose value is the `id` of another property, return a new array where
     * such layers have been augmented with the 'type', 'source', etc. properties
     * from the parent layer, and the `ref` property has been removed.
     *
     * The input is not modified. The output may contain references to portions
     * of the input.
     */
    layers = layers.slice(); // ??? What are we trying to achieve here?

    const map = Object.create(null); // stackoverflow.com/a/21079232/10082269
    layers.forEach( layer => { map[layer.id] = layer; } );

    for (let i = 0; i < layers.length; i++) {
      if ('ref' in layers[i]) {
        layers[i] = deref(layers[i], map[layers[i].ref]);
      }
    }

    return layers;
  }

  function deref(layer, parent) {
    const result = {};

    for (const k in layer) {
      if (k !== 'ref') {
        result[k] = layer[k];
      }
    }

    refProperties.forEach((k) => {
      if (k in parent) {
        result[k] = parent[k];
      }
    });

    return result;
  }

  function expandStyleURL(url, token) {
    var prefix = /^mapbox:\/\/styles\//;
    if ( !url.match(prefix) ) return url;
    var apiRoot = "https://api.mapbox.com/styles/v1/";
    return url.replace(prefix, apiRoot) + "?access_token=" + token;
  }

  function expandSpriteURLs(url, token) {
    // Returns an array containing urls to .png and .json files
    var prefix = /^mapbox:\/\/sprites\//;
    if ( !url.match(prefix) ) return {
      image: url + ".png", 
      meta: url + ".json",
    };

    // We have a Mapbox custom url. Expand to an absolute URL, as per the spec
    var apiRoot = "https://api.mapbox.com/styles/v1/";
    url = url.replace(prefix, apiRoot) + "/sprite";
    var tokenString = "?access_token=" + token;
    return {
      image: url + ".png" + tokenString, 
      meta: url + ".json" + tokenString,
    };
  }

  function expandTileURL(url, token) {
    var prefix = /^mapbox:\/\//;
    if ( !url.match(prefix) ) return url;
    var apiRoot = "https://api.mapbox.com/v4/";
    return url.replace(prefix, apiRoot) + ".json?secure&access_token=" + token;
  }

  function getJSON(dataHref) {
    // Wrap the fetch API to force a rejected promise if response is not OK
    const checkResponse = (response) => (response.ok)
      ? response.json()
      : Promise.reject(response); // Can check .status on returned response

    return fetch(dataHref).then(checkResponse);
  }

  function getImage(href) {
    const errMsg = "ERROR in getImage for href " + href;
    const img = new Image();

    return new Promise( (resolve, reject) => {
      img.onerror = () => reject(errMsg);

      img.onload = () => (img.complete && img.naturalWidth !== 0)
          ? resolve(img)
          : reject(errMsg);

      img.crossOrigin = "anonymous";
      img.src = href;
    });
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var csscolorparser = createCommonjsModule(function (module, exports) {
  // (c) Dean McNamee <dean@gmail.com>, 2012.
  //
  // https://github.com/deanm/css-color-parser-js
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to
  // deal in the Software without restriction, including without limitation the
  // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
  // sell copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  // IN THE SOFTWARE.

  // http://www.w3.org/TR/css3-color/
  var kCSSColorTable = {
    "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
    "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
    "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
    "beige": [245,245,220,1], "bisque": [255,228,196,1],
    "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
    "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
    "brown": [165,42,42,1], "burlywood": [222,184,135,1],
    "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
    "chocolate": [210,105,30,1], "coral": [255,127,80,1],
    "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
    "crimson": [220,20,60,1], "cyan": [0,255,255,1],
    "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
    "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
    "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
    "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
    "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
    "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
    "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
    "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
    "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
    "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
    "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
    "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
    "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
    "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
    "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
    "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
    "gray": [128,128,128,1], "green": [0,128,0,1],
    "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
    "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
    "indianred": [205,92,92,1], "indigo": [75,0,130,1],
    "ivory": [255,255,240,1], "khaki": [240,230,140,1],
    "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
    "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
    "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
    "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
    "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
    "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
    "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
    "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
    "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
    "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
    "limegreen": [50,205,50,1], "linen": [250,240,230,1],
    "magenta": [255,0,255,1], "maroon": [128,0,0,1],
    "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
    "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
    "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
    "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
    "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
    "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
    "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
    "navy": [0,0,128,1], "oldlace": [253,245,230,1],
    "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
    "orange": [255,165,0,1], "orangered": [255,69,0,1],
    "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
    "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
    "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
    "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
    "pink": [255,192,203,1], "plum": [221,160,221,1],
    "powderblue": [176,224,230,1], "purple": [128,0,128,1],
    "rebeccapurple": [102,51,153,1],
    "red": [255,0,0,1], "rosybrown": [188,143,143,1],
    "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
    "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
    "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
    "sienna": [160,82,45,1], "silver": [192,192,192,1],
    "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
    "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
    "snow": [255,250,250,1], "springgreen": [0,255,127,1],
    "steelblue": [70,130,180,1], "tan": [210,180,140,1],
    "teal": [0,128,128,1], "thistle": [216,191,216,1],
    "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
    "violet": [238,130,238,1], "wheat": [245,222,179,1],
    "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
    "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]};

  function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
    i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
    return i < 0 ? 0 : i > 255 ? 255 : i;
  }

  function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
    return f < 0 ? 0 : f > 1 ? 1 : f;
  }

  function parse_css_int(str) {  // int or percentage.
    if (str[str.length - 1] === '%')
      return clamp_css_byte(parseFloat(str) / 100 * 255);
    return clamp_css_byte(parseInt(str));
  }

  function parse_css_float(str) {  // float or percentage.
    if (str[str.length - 1] === '%')
      return clamp_css_float(parseFloat(str) / 100);
    return clamp_css_float(parseFloat(str));
  }

  function css_hue_to_rgb(m1, m2, h) {
    if (h < 0) h += 1;
    else if (h > 1) h -= 1;

    if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
    if (h * 2 < 1) return m2;
    if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
    return m1;
  }

  function parseCSSColor(css_str) {
    // Remove all whitespace, not compliant, but should just be more accepting.
    var str = css_str.replace(/ /g, '').toLowerCase();

    // Color keywords (and transparent) lookup.
    if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

    // #abc and #abc123 syntax.
    if (str[0] === '#') {
      if (str.length === 4) {
        var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
        if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
        return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
                (iv & 0xf0) | ((iv & 0xf0) >> 4),
                (iv & 0xf) | ((iv & 0xf) << 4),
                1];
      } else if (str.length === 7) {
        var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
        if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
        return [(iv & 0xff0000) >> 16,
                (iv & 0xff00) >> 8,
                iv & 0xff,
                1];
      }

      return null;
    }

    var op = str.indexOf('('), ep = str.indexOf(')');
    if (op !== -1 && ep + 1 === str.length) {
      var fname = str.substr(0, op);
      var params = str.substr(op+1, ep-(op+1)).split(',');
      var alpha = 1;  // To allow case fallthrough.
      switch (fname) {
        case 'rgba':
          if (params.length !== 4) return null;
          alpha = parse_css_float(params.pop());
          // Fall through.
        case 'rgb':
          if (params.length !== 3) return null;
          return [parse_css_int(params[0]),
                  parse_css_int(params[1]),
                  parse_css_int(params[2]),
                  alpha];
        case 'hsla':
          if (params.length !== 4) return null;
          alpha = parse_css_float(params.pop());
          // Fall through.
        case 'hsl':
          if (params.length !== 3) return null;
          var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
          // NOTE(deanm): According to the CSS spec s/l should only be
          // percentages, but we don't bother and let float or percentage.
          var s = parse_css_float(params[1]);
          var l = parse_css_float(params[2]);
          var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          var m1 = l * 2 - m2;
          return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                  clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                  clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                  alpha];
        default:
          return null;
      }
    }

    return null;
  }

  try { exports.parseCSSColor = parseCSSColor; } catch(e) { }
  });
  var csscolorparser_1 = csscolorparser.parseCSSColor;

  function buildInterpFunc(base, sampleVal) {
    // Return a function to interpolate the value of y(x), given endpoints
    // p0 = (x0, y0) and p2 = (x1, y1)

    const scale = getScale(base);
    const interpolate = getInterpolator(sampleVal);

    return (p0, x, p1) => interpolate( p0[1], scale(p0[0], x, p1[0]), p1[1] );
  }

  function getScale(base) {
    // Return a function to find the relative position of x between a and b

    // Exponential scale follows mapbox-gl-js, style-spec/function/index.js
    // NOTE: https://github.com/mapbox/mapbox-gl-js/issues/2698 not addressed!
    const scale = (base === 1)
      ? (a, x, b) => (x - a) / (b - a)  // Linear scale
      : (a, x, b) => (Math.pow(base, x - a) - 1) / (Math.pow(base, b - a) - 1);

    // Add check for zero range
    return (a, x, b) => (a === b)
      ? 0
      : scale(a, x, b);
  }

  function getInterpolator(sampleVal) {
    // Return a function to find an interpolated value between end values v1, v2,
    // given relative position t between the two end positions

    var type = typeof sampleVal;
    if (type === "string" && csscolorparser_1(sampleVal)) type = "color";

    switch (type) {
      case "number": // Linear interpolator
        return (v1, t, v2) => v1 + t * (v2 - v1);

      case "color":  // Interpolate RGBA
        return (v1, t, v2) => 
          interpColor( csscolorparser_1(v1), t, csscolorparser_1(v2) );

      default:       // Assume step function
        return (v1, t, v2) => v1;
    }
  }

  function interpColor(c0, t, c1) {
    // Inputs c0, c1 are 4-element RGBA arrays as returned by parseCSSColor
    let c = c0.map( (c0_i, i) => c0_i + t * (c1[i] - c0_i) );

    return "rgba(" +
      Math.round(c[0]) + ", " +
      Math.round(c[1]) + ", " + 
      Math.round(c[2]) + ", " +
      c[3] + ")";
  }

  function autoGetters(properties = {}, defaults) {
    const getters = {};
    Object.keys(defaults).forEach(key => {
      getters[key] = buildStyleFunc(properties[key], defaults[key]);
    });
    return getters;
  }

  function buildStyleFunc(style, defaultVal) {
    var styleFunc, getArg;

    if (style === undefined) {
      styleFunc = () => defaultVal;
      styleFunc.type = "constant";

    } else if (typeof style !== "object" || Array.isArray(style)) {
      styleFunc = () => style;
      styleFunc.type = "constant";

    } else if (!style.property || style.property === "zoom") {
      getArg = (zoom, feature) => zoom;
      styleFunc = getStyleFunc(style, getArg);
      styleFunc.type = "zoom";

    } else {
      let propertyName = style.property;
      getArg = (zoom, feature) => feature.properties[propertyName];
      styleFunc = getStyleFunc(style, getArg);
      styleFunc.type = "property";
      styleFunc.property = propertyName;

    } // NOT IMPLEMENTED: zoom-and-property functions

    return styleFunc;
  }

  function getStyleFunc(style, getArg) {
    if (style.type === "identity") return getArg;

    // We should be building a stop function now. Make sure we have enough info
    var stops = style.stops;
    if (!stops || stops.length < 2 || stops[0].length !== 2) {
      console.log("buildStyleFunc: style = " + JSON.stringify(style));
      console.log("ERROR in buildStyleFunc: failed to understand style!");
      return;
    }

    var stopFunc = buildStopFunc(stops, style.base);
    return (zoom, feature) => stopFunc( getArg(zoom, feature) );
  }

  function buildStopFunc(stops, base = 1) {
    const izm = stops.length - 1;
    const interpolateVal = buildInterpFunc(base, stops[0][1]);

    return function(x) {
      let iz = stops.findIndex(stop => stop[0] > x);

      if (iz === 0) return stops[0][1]; // x is below first stop
      if (iz < 0) return stops[izm][1]; // x is above last stop

      return interpolateVal(stops[iz-1], x, stops[iz]);
    }
  }

  const layoutDefaults = {
    "background": {
      "visibility": "visible",
    },
    "fill": {
      "visibility": "visible",
    },
    "line": {
      "visibility": "visible",
      "line-cap": "butt",
      "line-join": "miter",
      "line-miter-limit": 2,
      "line-round-limit": 1.05,
    },
    "symbol": {
      "visibility": "visible",

      "symbol-placement": "point",
      "symbol-spacing": 250,
      "symbol-avoid-edges": false,
      "symbol-sort-key": undefined,
      "symbol-z-order": "auto",

      "icon-allow-overlap": false,
      "icon-ignore-placement": false,
      "icon-optional": false,
      "icon-rotation-alignment": "auto",
      "icon-size": 1,
      "icon-text-fit": "none",
      "icon-text-fit-padding": [0, 0, 0, 0],
      "icon-image": undefined,
      "icon-rotate": 0,
      "icon-padding": 2,
      "icon-keep-upright": false,
      "icon-offset": [0, 0],
      "icon-anchor": "center",
      "icon-pitch-alignment": "auto",

      "text-pitch-alignment": "auto",
      "text-rotation-alignment": "auto",
      "text-field": "",
      "text-font": ["Open Sans Regular", "Arial Unicode MS Regular"],
      "text-size": 16,
      "text-max-width": 10,
      "text-line-height": 1.2,
      "text-letter-spacing": 0,
      "text-justify": "center",
      "text-radial-offset": 0,
      "text-variable-anchor": undefined,
      "text-anchor": "center",
      "text-max-angle": 45,
      "text-rotate": 0,
      "text-padding": 2.0,
      "text-keep-upright": true,
      "text-transform": "none",
      "text-offset": [0, 0],
      "text-allow-overlap": false,
      "text-ignore-placement": false,
      "text-optional": false,
    },
    "raster": {
      "visibility": "visible",
    },
    "circle": {
      "visibility": "visible",
    },
    "fill-extrusion": {
      "visibility": "visible",
    },
    "heatmap": {
      "visibility": "visible",
    },
    "hillshade": {
      "visibility": "visible",
    },
  };

  const paintDefaults = {
    "background": {
      "background-color": "#000000",
      "background-opacity": 1,
      "background-pattern": undefined,
    },
    "fill": {
      "fill-antialias": true,
      "fill-opacity": 1,
      "fill-color": "#000000",
      "fill-outline-color": undefined,
      "fill-outline-width": 1, // non-standard!
      "fill-translate": [0, 0],
      "fill-translate-anchor": "map",
      "fill-pattern": undefined,
    },
    "line": {
      "line-opacity": 1,
      "line-color": "#000000",
      "line-translate": [0, 0],
      "line-translate-anchor": "map",
      "line-width": 1,
      "line-gap-width": 0,
      "line-offset": 0,
      "line-blur": 0,
      "line-dasharray": undefined,
      "line-pattern": undefined,
      "line-gradient": undefined,
    },
    "symbol": {
      "icon-opacity": 1,
      "icon-color": "#000000",
      "icon-halo-color": "rgba(0, 0, 0, 0)",
      "icon-halo-width": 0,
      "icon-halo-blur": 0,
      "icon-translate": [0, 0],
      "icon-translate-anchor": "map",

      "text-opacity": 1,
      "text-color": "#000000",
      "text-halo-color": "rgba(0, 0, 0, 0)",
      "text-halo-width": 0,
      "text-halo-blur": 0,
      "text-translate": [0, 0],
      "text-translate-anchor": "map",
    },
    "raster": {
      "raster-opacity": 1,
      "raster-hue-rotate": 0,
      "raster-brighness-min": 0,
      "raster-brightness-max": 1,
      "raster-saturation": 0,
      "raster-contrast": 0,
      "raster-resampling": "linear",
      "raster-fade-duration": 300,
    },
    "circle": {
      "circle-radius": 5,
      "circle-color": "#000000",
      "circle-blur": 0,
      "circle-opacity": 1,
      "circle-translate": [0, 0],
      "circle-translate-anchor": "map",
      "circle-pitch-scale": "map",
      "circle-pitch-alignment": "viewport",
      "circle-stroke-width": 0,
      "circle-stroke-color": "#000000",
      "circle-stroke-opacity": 1,
    },
    "fill-extrusion": {
      "fill-extrusion-opacity": 1,
      "fill-extrusion-color": "#000000",
      "fill-extrusion-translate": [0, 0],
      "fill-extrusion-translate-anchor": "map",
      "fill-extrusion-height": 0,
      "fill-extrusion-base": 0,
      "fill-extrusion-vertical-gradient": true,
    },
    "heatmap": {
      "heatmap-radius": 30,
      "heatmap-weight": 1,
      "heatmap-intensity": 1,
      "heatmap-color": ["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255,0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],
      "heatmap-opacity": 1,
    },
    "hillshade": {
      "hillshade-illumination-direction": 335,
      "hillshade-illumination-anchor": "viewport",
      "hillshade-exaggeration": 0.5,
      "hillshade-shadow-color": "#000000",
      "hillshade-highlight-color": "#FFFFFF",
      "hillshade-accent-color": "#000000",
    },
  };

  function getStyleFuncs(inputLayer) {
    const layer = Object.assign({}, inputLayer); // Leave input unchanged

    // Replace rendering properties with functions
    layer.layout = autoGetters(layer.layout, layoutDefaults[layer.type]);
    layer.paint  = autoGetters(layer.paint,  paintDefaults[layer.type] );

    return layer;
  }

  function loadStyle(style, mapboxToken) {
    // Loads a style document and any linked information

    const getStyle = (typeof style === "object")
      ? Promise.resolve(style)                // style is JSON already
      : getJSON( expandStyleURL(style, mapboxToken) ); // Get from URL

    return getStyle
      .then( styleDoc => expandLinks(styleDoc, mapboxToken) );
  }

  function expandLinks(styleDoc, mapboxToken) {
    styleDoc.layers = derefLayers(styleDoc.layers);

    return Promise.all([
      expandSources(styleDoc.sources, mapboxToken),
      loadSprite(styleDoc.sprite, mapboxToken),
    ]).then( ([sources, spriteData]) => {
      styleDoc.sources = sources;
      styleDoc.spriteData = spriteData;
      return styleDoc;
    });
  }

  function expandSources(rawSources, token) {
    const expandPromises = Object.entries(rawSources).map(expandSource);

    function expandSource([key, source]) {
      // If no .url, return a shallow copy of the input. 
      // Note: some properties may still be pointing back to the original 
      // style document, like .vector_layers, .bounds, .center, .extent
      if (source.url === undefined) return [key, Object.assign({}, source)];

      // Load the referenced TileJSON document, add any values from source
      return getJSON( expandTileURL(source.url, token) )
        .then( tileJson => [key, Object.assign(tileJson, source)] );
    }

    function combineSources(keySourcePairs) {
      const sources = {};
      keySourcePairs.forEach( ([key, val]) => { sources[key] = val; } );
      return sources;
    }

    return Promise.all( expandPromises ).then( combineSources );
  }

  function loadSprite(sprite, token) {
    if (!sprite) return;

    const urls = expandSpriteURLs(sprite, token);

    return Promise.all([getImage(urls.image), getJSON(urls.meta)])
      .then( ([image, meta]) => ({ image, meta }) );
  }

  initZeroTimeouts();

  function initZeroTimeouts() {
    // setTimeout with true zero delay. https://github.com/GlobeletJS/zero-timeout
    const timeouts = [];
    var taskId = 0;

    // Make a unique message, that won't be confused with messages from
    // other scripts or browser tabs
    const messageKey = "zeroTimeout_$" + Math.random().toString(36).slice(2);

    // Make it clear where the messages should be coming from
    const loc = window.location;
    var targetOrigin = loc.protocol + "//" + loc.hostname;
    if (loc.port !== "") targetOrigin += ":" + loc.port;

    // When a message is received, execute a timeout from the list
    window.addEventListener("message", evnt => {
      if (evnt.source != window || evnt.data !== messageKey) return;
      evnt.stopPropagation();

      let task = timeouts.shift();
      if (!task || task.canceled) return;
      task.func(...task.args);
    }, true);

    // Now define the external functions to set or cancel a timeout
    window.setZeroTimeout = function(func, ...args) {
      timeouts.push({ id: taskId++, func, args });
      window.postMessage(messageKey, targetOrigin);
      return taskId;
    };

    window.clearZeroTimeout = function(id) {
      let task = timeouts.find(timeout => timeout.id === id);
      if (task) task.canceled = true;
    };
  }

  function init$1() {
    const tasks = [];
    var taskId = 0;
    var queueIsRunning = false;

    return {
      enqueueTask,
      cancelTask,
      sortTasks,
    };

    function enqueueTask(newTask) {
      let defaultPriority = () => 0;
      tasks.push({ 
        id: taskId++,
        getPriority: newTask.getPriority || defaultPriority,
        chunks: newTask.chunks,
      });
      if (!queueIsRunning) setZeroTimeout(runTaskQueue);
      return taskId;
    }

    function cancelTask(id) {
      let task = tasks.find(task => task.id === id);
      if (task) task.canceled = true;
    }

    function sortTasks() {
      tasks.sort( (a, b) => compareNums(a.getPriority(), b.getPriority()) );
    }

    function compareNums(a, b) {
      if (a === b) return 0;
      return (a === undefined || a < b) ? -1 : 1;
    }

    function runTaskQueue() {
      // Remove canceled and completed tasks
      while (isDone(tasks[0])) tasks.shift();

      queueIsRunning = (tasks.length > 0);
      if (!queueIsRunning) return;

      // Get the next chunk from the current task, and run it
      let chunk = tasks[0].chunks.shift();
      chunk();

      setZeroTimeout(runTaskQueue);
    }

    function isDone(task) {
      return task && (task.canceled || task.chunks.length < 1);
    }
  }

  initZeroTimeouts$1();

  function initZeroTimeouts$1() {
    // setTimeout with true zero delay. https://github.com/GlobeletJS/zero-timeout
    const timeouts = [];
    var taskId = 0;

    // Make a unique message, that won't be confused with messages from
    // other scripts or browser tabs
    const messageKey = "zeroTimeout_$" + Math.random().toString(36).slice(2);

    // Make it clear where the messages should be coming from
    const loc = window.location;
    var targetOrigin = loc.protocol + "//" + loc.hostname;
    if (loc.port !== "") targetOrigin += ":" + loc.port;

    // When a message is received, execute a timeout from the list
    window.addEventListener("message", evnt => {
      if (evnt.source != window || evnt.data !== messageKey) return;
      evnt.stopPropagation();

      let task = timeouts.shift();
      if (!task || task.canceled) return;
      task.func(...task.args);
    }, true);

    // Now define the external functions to set or cancel a timeout
    window.setZeroTimeout = function(func, ...args) {
      timeouts.push({ id: taskId++, func, args });
      window.postMessage(messageKey, targetOrigin);
      return taskId;
    };

    window.clearZeroTimeout = function(id) {
      let task = timeouts.find(timeout => timeout.id === id);
      if (task) task.canceled = true;
    };
  }

  function init$1$1() {
    const tasks = [];
    var taskId = 0;
    var queueIsRunning = false;

    return {
      enqueueTask,
      cancelTask,
      sortTasks,
    };

    function enqueueTask(newTask) {
      let defaultPriority = () => 0;
      tasks.push({ 
        id: taskId++,
        getPriority: newTask.getPriority || defaultPriority,
        chunks: newTask.chunks,
      });
      if (!queueIsRunning) setZeroTimeout(runTaskQueue);
      return taskId;
    }

    function cancelTask(id) {
      let task = tasks.find(task => task.id === id);
      if (task) task.canceled = true;
    }

    function sortTasks() {
      tasks.sort( (a, b) => compareNums(a.getPriority(), b.getPriority()) );
    }

    function compareNums(a, b) {
      if (a === b) return 0;
      return (a === undefined || a < b) ? -1 : 1;
    }

    function runTaskQueue() {
      // Remove canceled and completed tasks
      while (isDone(tasks[0])) tasks.shift();

      queueIsRunning = (tasks.length > 0);
      if (!queueIsRunning) return;

      // Get the next chunk from the current task, and run it
      let chunk = tasks[0].chunks.shift();
      chunk();

      setZeroTimeout(runTaskQueue);
    }

    function isDone(task) {
      return task && (task.canceled || task.chunks.length < 1);
    }
  }

  const vectorTypes = ["symbol", "circle", "line", "fill"];

  function setParams$1(userParams) {
    const threads = userParams.threads || 2;

    // Confirm supplied styles are all vector layers reading from the same source
    const layers = userParams.layers;
    if (!layers || !layers.length) fail("no valid array of style layers!");

    let allVectors = layers.every( l => vectorTypes.includes(l.type) );
    if (!allVectors) fail("not all layers are vector types!");

    let sameSource = layers.every( l => l.source === layers[0].source );
    if (!sameSource) fail("supplied layers use different sources!");

    // Construct function to get a tile URL
    if (!userParams.source) fail("parameters.source is required!");
    const getURL = initUrlFunc(userParams.source.tiles);

    // Construct the task queue, if not supplied
    const queue = (userParams.queue)
      ? userParams.queue
      : init$1$1();

    return {
      threads,
      layers,
      getURL,
      queue
    };
  }

  function initUrlFunc(endpoints) {
    if (!endpoints || !endpoints.length) fail("no valid tile endpoints!");

    // Use a different endpoint for each request
    var index = 0;

    return function(z, x, y) {
      index = (index + 1) % endpoints.length;
      var endpoint = endpoints[index];
      return endpoint.replace(/{z}/, z).replace(/{x}/, x).replace(/{y}/, y);
    };
  }

  function fail(message) {
    throw Error("ERROR in tile-mixer: " + message);
  }

  function initWorkers(nThreads, codeHref, styles) {
    const tasks = {};
    var globalMsgId = 0;

    // Initialize the worker threads, and send them the styles
    function trainWorker() {
      const worker = new Worker(codeHref);
      worker.postMessage({ id: 0, type: "styles", payload: styles });
      worker.onmessage = handleMsg;
      return worker;
    }
    const workers = Array.from(Array(nThreads), trainWorker);
    const workLoads = Array.from(Array(nThreads), () => 0);

    return {
      startTask,
      cancelTask,
      activeTasks: () => workLoads.reduce( (a, b) => a + b, 0 ),
      terminate: () => workers.forEach( worker => worker.terminate() ),
    }

    function startTask(payload, callback) {
      let workerID = getIdleWorkerID(workLoads);
      workLoads[workerID] ++;

      const msgId = ++globalMsgId; // Start from 1, since we used 0 for styles
      tasks[msgId] = { callback, workerID };
      workers[workerID].postMessage({ id: msgId, type: "start", payload });

      return msgId; // Returned ID can be used for later cancellation
    }

    function cancelTask(id) {
      let task = tasks[id];
      if (!task) return;
      workers[task.workerID].postMessage({ id, type: "cancel" });
      workLoads[task.workerID] --;
      delete tasks[id];
    }

    function handleMsg(msgEvent) {
      const msg = msgEvent.data; // { id, type, key, payload }
      const task = tasks[msg.id];
      // NOTE: 'this' is the worker that emitted msgEvent
      if (!task) return this.postMessage({ id: msg.id, type: "cancel" });

      switch (msg.type) {
        case "error":
          task.callback(msg.payload);
          break; // Clean up below

        case "header":
          task.header = msg.payload;
          task.result = initJSON(msg.payload);
          return this.postMessage({ id: msg.id, type: "continue" });

        case "compressed":
        case "features":
          let features = task.result[msg.key][msg.type];
          msg.payload.forEach( feature => features.push(feature) );
          return this.postMessage({ id: msg.id, type: "continue" });

        case "done":
          let err = checkResult(task.result, task.header);
          task.callback(err, task.result);
          break; // Clean up below

        default:
          task.callback("ERROR: worker sent bad message type!");
          break; // Clean up below
      }

      workLoads[task.workerID] --;
      delete tasks[msg.id];
    }
  }

  function getIdleWorkerID(workLoads) {
    let id = 0;
    for (let i = 1; i < workLoads.length; i++) {
      if (workLoads[i] < workLoads[id]) id = i;
    }
    return id;
  }

  function initJSON(headers) {
    const json = {};
    Object.entries(headers).forEach( ([key, hdr]) => {
      json[key] = { type: "FeatureCollection", compressed: [] };
      if (hdr.features) json[key].features = [];
      if (hdr.properties) json[key].properties = hdr.properties;
    });
    return json;
  }

  function checkResult(json, header) {
    let allOk = Object.keys(header)
      .every( k => checkData(json[k], header[k]) );

    return allOk
      ? null
      : "ERROR: JSON from worker failed checks!";
  }

  function checkData(data, counts) {
    // data is a GeoJSON Feature Collection, augmented with 'compressed' array
    var ok = data.compressed.length === counts.compressed;
    if (counts.features) {
      // We also have raw GeoJSON for querying. Check the length
      ok = ok && data.features.length === counts.features;
    }
    return ok;
  }

  function pointPath(path, point) {
    // Draws a Point geometry, which is an array of two coordinates
    path.moveTo(point[0], point[1]);
    path.lineTo(point[0], point[1]);
  }

  function linePath(path, points) {
    // Draws a LineString geometry, which is an array of Points.
    var p = points[0], i = 0, n = points.length;
    path.moveTo(p[0], p[1]);
    while (++i < n) p = points[i], path.lineTo(p[0], p[1]);
  }

  function polygonPath(path, lines) {
    // Draws a Polygon geometry, which is an array of LineStrings
    var i = -1, n = lines.length;
    while (++i < n) linePath(path, lines[i]);
  }

  const pathFuncs = {
    Point: pointPath,
    LineString: linePath,
    Polygon: polygonPath,
  };

  function geomToPath(geometry) {
    // Converts a GeoJSON Feature geometry to a Path2D object

    var type = geometry.type;
    var isMulti = type.substring(0, 5) === "Multi";
    if (isMulti) type = type.substring(5);

    const pathFunc = pathFuncs[type];

    const path = new Path2D();

    const coords = geometry.coordinates;
    if (isMulti) {
      // While loops faster than forEach: https://jsperf.com/loops/32
      var i = -1, n = coords.length;
      while (++i < n) pathFunc(path, coords[i]);

    } else {
      pathFunc(path, coords);
    }

    return path;
  }

  function initDataPrep(styles) {
    // Build a dictionary of data prep functions, keyed on style.id
    const prepFunctions = {};
    styles.forEach(style => {
      prepFunctions[style.id] = (style.type === "symbol")
        ? initTextMeasurer()
        : addPaths;
    });

    // Return a function that creates an array of prep calls for a source
    return function (source, zoom) {
      return Object.keys(source)
        .map( id => () => prepFunctions[id](source[id], zoom) );
    };
  }

  function initTextMeasurer(style) {
    // TODO: This closure only saves one createElement call. Is it worth it?
    const ctx = document.createElement("canvas").getContext("2d");

    return function(data, zoom) {
      ctx.font = data.properties.font;

      data.compressed.forEach(feature => {
        let labelText = feature.properties.labelText;
        if (!labelText) return;
        feature.properties.textWidth = ctx.measureText(labelText).width;
      });

      return data;
    };
  }

  function addPaths(data) {
    data.compressed.forEach(feature => {
      // TODO: Does this need to be interruptable?
      feature.path = geomToPath(feature.geometry);
      delete feature.geometry; // Allow it to be garbage collected
    });

    return data;
  }

  var workerCode = String.raw`function buildFeatureFilter(filterObj) {
  // filterObj is a filter definition following the "deprecated" syntax:
  // https://docs.mapbox.com/mapbox-gl-js/style-spec/#other-filter
  if (!filterObj) return () => true;

  var type, key, vals;

  // If this is a combined filter, the vals are themselves filter definitions
  [type, ...vals] = filterObj;
  switch (type) {
    case "all": {
      let filters = vals.map(buildFeatureFilter);  // Iteratively recursive!
      return (d) => filters.every( filt => filt(d) );
    }
    case "any": {
      let filters = vals.map(buildFeatureFilter);
      return (d) => filters.some( filt => filt(d) );
    }
    case "none": {
      let filters = vals.map(buildFeatureFilter);
      return (d) => filters.every( filt => !filt(d) );
    }
  }

  [type, key, ...vals] = filterObj;
  var getVal = initFeatureValGetter(key);

  switch (type) {
    // Existential Filters
    case "has": 
      return d => !!getVal(d); // !! forces a Boolean return
    case "!has": 
      return d => !getVal(d);

    // Comparison Filters
    case "==": 
      return d => getVal(d) === vals[0];
    case "!=":
      return d => getVal(d) !== vals[0];
    case ">":
      return d => getVal(d) > vals[0];
    case ">=":
      return d => getVal(d) >= vals[0];
    case "<":
      return d => getVal(d) < vals[0];
    case "<=":
      return d => getVal(d) <= vals[0];

    // Set Membership Filters
    case "in" :
      return d => vals.includes( getVal(d) );
    case "!in" :
      return d => !vals.includes( getVal(d) );
    default:
      console.log("prepFilter: unknown filter type = " + filterObj[0]);
  }
  // No recognizable filter criteria. Return a filter that is always true
  return () => true;
}

function initFeatureValGetter(key) {
  switch (key) {
    case "$type":
      // NOTE: data includes MultiLineString, MultiPolygon, etc-NOT IN SPEC
      return f => {
        let t = f.geometry.type;
        if (t === "MultiPoint") return "Point";
        if (t === "MultiLineString") return "LineString";
        if (t === "MultiPolygon") return "Polygon";
        return t;
      };
    case "$id":
      return f => f.id;
    default:
      return f => f.properties[key];
  }
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var csscolorparser = createCommonjsModule(function (module, exports) {
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "rebeccapurple": [102,51,153,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]};

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor; } catch(e) { }
});
var csscolorparser_1 = csscolorparser.parseCSSColor;

function buildInterpFunc(base, sampleVal) {
  // Return a function to interpolate the value of y(x), given endpoints
  // p0 = (x0, y0) and p2 = (x1, y1)

  const scale = getScale(base);
  const interpolate = getInterpolator(sampleVal);

  return (p0, x, p1) => interpolate( p0[1], scale(p0[0], x, p1[0]), p1[1] );
}

function getScale(base) {
  // Return a function to find the relative position of x between a and b

  // Exponential scale follows mapbox-gl-js, style-spec/function/index.js
  // NOTE: https://github.com/mapbox/mapbox-gl-js/issues/2698 not addressed!
  const scale = (base === 1)
    ? (a, x, b) => (x - a) / (b - a)  // Linear scale
    : (a, x, b) => (Math.pow(base, x - a) - 1) / (Math.pow(base, b - a) - 1);

  // Add check for zero range
  return (a, x, b) => (a === b)
    ? 0
    : scale(a, x, b);
}

function getInterpolator(sampleVal) {
  // Return a function to find an interpolated value between end values v1, v2,
  // given relative position t between the two end positions

  var type = typeof sampleVal;
  if (type === "string" && csscolorparser_1(sampleVal)) type = "color";

  switch (type) {
    case "number": // Linear interpolator
      return (v1, t, v2) => v1 + t * (v2 - v1);

    case "color":  // Interpolate RGBA
      return (v1, t, v2) => 
        interpColor( csscolorparser_1(v1), t, csscolorparser_1(v2) );

    default:       // Assume step function
      return (v1, t, v2) => v1;
  }
}

function interpColor(c0, t, c1) {
  // Inputs c0, c1 are 4-element RGBA arrays as returned by parseCSSColor
  let c = c0.map( (c0_i, i) => c0_i + t * (c1[i] - c0_i) );

  return "rgba(" +
    Math.round(c[0]) + ", " +
    Math.round(c[1]) + ", " + 
    Math.round(c[2]) + ", " +
    c[3] + ")";
}

function autoGetters(properties = {}, defaults) {
  const getters = {};
  Object.keys(defaults).forEach(key => {
    getters[key] = buildStyleFunc(properties[key], defaults[key]);
  });
  return getters;
}

function buildStyleFunc(style, defaultVal) {
  var styleFunc, getArg;

  if (style === undefined) {
    styleFunc = () => defaultVal;
    styleFunc.type = "constant";

  } else if (typeof style !== "object" || Array.isArray(style)) {
    styleFunc = () => style;
    styleFunc.type = "constant";

  } else if (!style.property || style.property === "zoom") {
    getArg = (zoom, feature) => zoom;
    styleFunc = getStyleFunc(style, getArg);
    styleFunc.type = "zoom";

  } else {
    let propertyName = style.property;
    getArg = (zoom, feature) => feature.properties[propertyName];
    styleFunc = getStyleFunc(style, getArg);
    styleFunc.type = "property";
    styleFunc.property = propertyName;

  } // NOT IMPLEMENTED: zoom-and-property functions

  return styleFunc;
}

function getStyleFunc(style, getArg) {
  if (style.type === "identity") return getArg;

  // We should be building a stop function now. Make sure we have enough info
  var stops = style.stops;
  if (!stops || stops.length < 2 || stops[0].length !== 2) {
    console.log("buildStyleFunc: style = " + JSON.stringify(style));
    console.log("ERROR in buildStyleFunc: failed to understand style!");
    return;
  }

  var stopFunc = buildStopFunc(stops, style.base);
  return (zoom, feature) => stopFunc( getArg(zoom, feature) );
}

function buildStopFunc(stops, base = 1) {
  const izm = stops.length - 1;
  const interpolateVal = buildInterpFunc(base, stops[0][1]);

  return function(x) {
    let iz = stops.findIndex(stop => stop[0] > x);

    if (iz === 0) return stops[0][1]; // x is below first stop
    if (iz < 0) return stops[izm][1]; // x is above last stop

    return interpolateVal(stops[iz-1], x, stops[iz]);
  }
}

const layoutDefaults = {
  "background": {
    "visibility": "visible",
  },
  "fill": {
    "visibility": "visible",
  },
  "line": {
    "visibility": "visible",
    "line-cap": "butt",
    "line-join": "miter",
    "line-miter-limit": 2,
    "line-round-limit": 1.05,
  },
  "symbol": {
    "visibility": "visible",

    "symbol-placement": "point",
    "symbol-spacing": 250,
    "symbol-avoid-edges": false,
    "symbol-sort-key": undefined,
    "symbol-z-order": "auto",

    "icon-allow-overlap": false,
    "icon-ignore-placement": false,
    "icon-optional": false,
    "icon-rotation-alignment": "auto",
    "icon-size": 1,
    "icon-text-fit": "none",
    "icon-text-fit-padding": [0, 0, 0, 0],
    "icon-image": undefined,
    "icon-rotate": 0,
    "icon-padding": 2,
    "icon-keep-upright": false,
    "icon-offset": [0, 0],
    "icon-anchor": "center",
    "icon-pitch-alignment": "auto",

    "text-pitch-alignment": "auto",
    "text-rotation-alignment": "auto",
    "text-field": "",
    "text-font": ["Open Sans Regular", "Arial Unicode MS Regular"],
    "text-size": 16,
    "text-max-width": 10,
    "text-line-height": 1.2,
    "text-letter-spacing": 0,
    "text-justify": "center",
    "text-radial-offset": 0,
    "text-variable-anchor": undefined,
    "text-anchor": "center",
    "text-max-angle": 45,
    "text-rotate": 0,
    "text-padding": 2.0,
    "text-keep-upright": true,
    "text-transform": "none",
    "text-offset": [0, 0],
    "text-allow-overlap": false,
    "text-ignore-placement": false,
    "text-optional": false,
  },
  "raster": {
    "visibility": "visible",
  },
  "circle": {
    "visibility": "visible",
  },
  "fill-extrusion": {
    "visibility": "visible",
  },
  "heatmap": {
    "visibility": "visible",
  },
  "hillshade": {
    "visibility": "visible",
  },
};

const paintDefaults = {
  "background": {
    "background-color": "#000000",
    "background-opacity": 1,
    "background-pattern": undefined,
  },
  "fill": {
    "fill-antialias": true,
    "fill-opacity": 1,
    "fill-color": "#000000",
    "fill-outline-color": undefined,
    "fill-outline-width": 1, // non-standard!
    "fill-translate": [0, 0],
    "fill-translate-anchor": "map",
    "fill-pattern": undefined,
  },
  "line": {
    "line-opacity": 1,
    "line-color": "#000000",
    "line-translate": [0, 0],
    "line-translate-anchor": "map",
    "line-width": 1,
    "line-gap-width": 0,
    "line-offset": 0,
    "line-blur": 0,
    "line-dasharray": undefined,
    "line-pattern": undefined,
    "line-gradient": undefined,
  },
  "symbol": {
    "icon-opacity": 1,
    "icon-color": "#000000",
    "icon-halo-color": "rgba(0, 0, 0, 0)",
    "icon-halo-width": 0,
    "icon-halo-blur": 0,
    "icon-translate": [0, 0],
    "icon-translate-anchor": "map",

    "text-opacity": 1,
    "text-color": "#000000",
    "text-halo-color": "rgba(0, 0, 0, 0)",
    "text-halo-width": 0,
    "text-halo-blur": 0,
    "text-translate": [0, 0],
    "text-translate-anchor": "map",
  },
  "raster": {
    "raster-opacity": 1,
    "raster-hue-rotate": 0,
    "raster-brighness-min": 0,
    "raster-brightness-max": 1,
    "raster-saturation": 0,
    "raster-contrast": 0,
    "raster-resampling": "linear",
    "raster-fade-duration": 300,
  },
  "circle": {
    "circle-radius": 5,
    "circle-color": "#000000",
    "circle-blur": 0,
    "circle-opacity": 1,
    "circle-translate": [0, 0],
    "circle-translate-anchor": "map",
    "circle-pitch-scale": "map",
    "circle-pitch-alignment": "viewport",
    "circle-stroke-width": 0,
    "circle-stroke-color": "#000000",
    "circle-stroke-opacity": 1,
  },
  "fill-extrusion": {
    "fill-extrusion-opacity": 1,
    "fill-extrusion-color": "#000000",
    "fill-extrusion-translate": [0, 0],
    "fill-extrusion-translate-anchor": "map",
    "fill-extrusion-height": 0,
    "fill-extrusion-base": 0,
    "fill-extrusion-vertical-gradient": true,
  },
  "heatmap": {
    "heatmap-radius": 30,
    "heatmap-weight": 1,
    "heatmap-intensity": 1,
    "heatmap-color": ["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255,0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],
    "heatmap-opacity": 1,
  },
  "hillshade": {
    "hillshade-illumination-direction": 335,
    "hillshade-illumination-anchor": "viewport",
    "hillshade-exaggeration": 0.5,
    "hillshade-shadow-color": "#000000",
    "hillshade-highlight-color": "#FFFFFF",
    "hillshade-accent-color": "#000000",
  },
};

function parseLayer(inputLayer) {
  // Like getStyleFuncs, but also parses the filter. DEPRECATED
  const layer = Object.assign({}, inputLayer); // Leave input unchanged

  layer.layout = autoGetters(layer.layout, layoutDefaults[layer.type]);
  layer.paint  = autoGetters(layer.paint,  paintDefaults[layer.type] );
  layer.filter = buildFeatureFilter(layer.filter);

  return layer;
}

function initFeatureGrouper(style) {
  // Find the names of the feature properties that affect rendering
  const renderProps = Object.values(style.layout)
    .concat(Object.values(style.paint))
    .filter(styleFunc => styleFunc.type === "property")
    .map(styleFunc => styleFunc.property);

  // Return a function to group features that will be styled the same
  return (renderProps.length > 0)
    ? (features) => groupFeatures(features, trimProps)
    : combineFeatures;

  function trimProps(properties) {
    let trimmed = {};
    renderProps.forEach(key => {
      trimmed[key] = properties[key];
    });
    return trimmed;
  }
}

function groupFeatures(features, selectProperties) {
  // Group features that will be styled the same
  const groups = {};
  features.forEach(feature => {
    // Keep only the properties relevant to rendering
    let properties = selectProperties(feature.properties);

    // Look up the appropriate group, or create it if it doesn't exist
    let key = Object.entries(properties).join();
    if (!groups[key]) groups[key] = initFeature(feature, properties);

    // Add this feature's coordinates to the grouped feature
    addCoords(groups[key].geometry.coordinates, feature.geometry);
  });

  return Object.values(groups).map(checkType);
}

function combineFeatures(features) {
  // No feature-dependent styles -- combine all features into one
  var group = initFeature(features[0]);
  features.forEach(f => addCoords(group.geometry.coordinates, f.geometry));
  return [ checkType(group) ];
}

function initFeature(template, properties) {
  var type = template.geometry.type;
  return {
    //type: "Feature", // Required by GeoJSON, but not needed for rendering
    geometry: { type, coordinates: [] },
    properties: properties,
  };
}

function addCoords(coords, geom) {
  if (geom.type.substring(0, 5) === "Multi") {
    geom.coordinates.forEach(coord => coords.push(coord));
  } else {
    coords.push(geom.coordinates);
  }
}

function checkType(feature) {
  // Check if we have a Multi-* geometry, and make sure it is labeled correctly
  let geom = feature.geometry;
  let labeledMulti = geom.type.substring(0, 5) === "Multi";

  if (geom.coordinates.length < 2) {  // Not Multi
    geom.coordinates = geom.coordinates[0];
    if (labeledMulti) geom.type = geom.type.substring(5);

  } else if (!labeledMulti) {
    geom.type = "Multi" + geom.type;
  }

  return feature;
}

function getTokenParser(tokenText) {
  if (!tokenText) return () => undefined;
  const tokenPattern = /{([^{}]+)}/g;

  // We break tokenText into pieces that are either plain text or tokens,
  // then construct an array of functions to parse each piece
  var tokenFuncs = [];
  var charIndex  = 0;
  while (charIndex < tokenText.length) {
    // Find the next token
    let result = tokenPattern.exec(tokenText);

    if (!result) {
      // No tokens left. Parse the plain text after the last token
      let str = tokenText.substring(charIndex);
      tokenFuncs.push(props => str);
      break;
    } else if (result.index > charIndex) {
      // There is some plain text before the token
      let str = tokenText.substring(charIndex, result.index);
      tokenFuncs.push(props => str);
    }

    // Add a function to process the current token
    let token = result[1];
    tokenFuncs.push(props => props[token]);
    charIndex = tokenPattern.lastIndex;
  }
  
  // We now have an array of functions returning either a text string or
  // a feature property
  // Return a function that assembles everything
  return function(properties) {
    return tokenFuncs.reduce(concat, "");
    function concat(str, tokenFunc) {
      let text = tokenFunc(properties) || "";
      return str += text;
    }
  };
}

// https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Common_weight_name_mapping
// Some obscure names from https://css3-tutorial.net/text-font/font-weight/
// But the 2 sources conflict!! The mapping is not standardized!
const fontWeights = {
  "thin": 100,
  "hairline": 100,
  "extra-light": 200,
  "ultra-light": 200,
  "light": 300,
  "book": 300,
  "regular": 400,
  "normal": 400,
  "plain": 400,
  "roman": 400,
  "standard": 400,
  "medium": 500,
  "semi-bold": 600,
  "demi-bold": 600,
  "bold": 700,
  "extra-bold": 800,
  "ultra-bold": 800,
  "heavy": 900,
  "black": 900,
  "fat": 900,
  "poster": 900,
  "ultra-black": 950,
  "extra-black": 950,
  "heavy-black": 950,
};
const wNames = Object.keys(fontWeights);

function popFontWeight(words, defaultWeight) {
  // Input words is an array of words from a font descriptor string, 
  // where the last word (or two) may contain font-weight info. 
  // Returns a numeric font-weight (if found), or defaultWeight
  // NOTES
  //  - ASSUMES font-style info (italics) has already been removed.
  //  - Input words array may be shortened!

  // If the last word is already a numeric weight, just remove and return it
  if (typeof words.slice(-1)[0] === "number") return words.pop();

  // Check if the last word matches one of the weight names in the dictionary
  var test = words.slice(-1)[0].toLowerCase();
  let wName = wNames.find(w => w == test || w.replace("-", "") == test);
  if (wName) {
    words.pop();
    return fontWeights[wName];
  }

  // Try again with the last 2 words
  test = words.slice(-2).join(" ").toLowerCase();
  wName = wNames.find(w => w.replace("-", " ") == test);
  if (wName) {
    words.pop();
    words.pop();
  }
  return fontWeights[wName] || defaultWeight;
}

const italicRE = /(italic|oblique)$/i;
const fontCache = {};

function getFontString(fonts, size, lineHeight) {
  // TODO: Need to pre-load all needed fonts, using FontFace API
  if (!Array.isArray(fonts)) fonts = [fonts];

  // Check if we already calculated the CSS for this font
  var cssData = fontCache[fonts.join(",")];
  if (cssData) return combine(cssData, size, lineHeight);

  var weight = 400;
  var style = 'normal';
  var fontFamilies = [];
  fonts.forEach(font => {
    var parts = font.split(' ');

    // Get font-style from end of string
    var maybeStyle = parts[parts.length - 1].toLowerCase();
    if (["normal", "italic", "oblique"].includes(maybeStyle)) {
      style = maybeStyle;
      parts.pop();
    } else if (italicRE.test(maybeStyle)) {
      // Style is part of the last word. Separate the parts
      // NOTE: haven't seen an example of this?
      // Idea from the mapbox-to-css module on NPM
      style = italicRE.exec(maybeStyle)[0];
      parts[parts.length - 1].replace(italicRE, '');
    }

    // Get font-weight
    weight = popFontWeight(parts, weight);

    // Get font-family
    // Special handling for Noto Sans, from mapbox-to-css module on NPM
    var fontFamily = parts.join(" ")
      .replace('Klokantech Noto Sans', 'Noto Sans');
    if (fontFamily.indexOf(" ") !== -1) { // Multi-word string. Wrap it in quotes
      fontFamily = '"' + fontFamily + '"';
    }
    fontFamilies.push(fontFamily);
  });

  fontFamilies.push("sans-serif"); // Last resort fallback

  // CSS font property: font-style font-weight font-size/line-height font-family
  cssData = fontCache[fonts.join(",")] = [style, weight, fontFamilies];

  return combine(cssData, size, lineHeight);
}
function combine(cssData, size, lineHeight) {
  // Round fontSize to the nearest 0.1 pixel
  size = Math.round(10.0 * size) * 0.1;

  // Combine with line height
  let sizes = (lineHeight) 
    ? size + "px/" + lineHeight 
    : size + "px";

  return [cssData[0], cssData[1], sizes, cssData[2]].join(" ");
}

function initLabelParser(style) {
  const layout = style.layout;

  // Return a function to compute label text and sprite ID
  return function(features, zoom) {
    const getSpriteID = getTokenParser( layout["icon-image"](zoom) );
    const parseText = getTokenParser( layout["text-field"](zoom) );
    const transformText = getTextTransform( layout["text-transform"](zoom) );

    function getProps(properties) {
      var spriteID = getSpriteID(properties);
      var labelText = parseText(properties);
      if (labelText) labelText = transformText(labelText);
      return { spriteID, labelText };
    }

    return features.map( f => initLabel(f.geometry, getProps(f.properties)) );
  }
}

function initLabel(geometry, properties) {
  return {
    //type: "Feature",  // Required by GeoJSON, but not needed for rendering
    geometry,
    properties,
  };
}

function getTextTransform(code) {
  switch (code) {
    case "uppercase":
      return f => f.toUpperCase();
    case "lowercase":
      return f => f.toLowerCase();
    case "none":
    default:
      return f => f;
  }
}

function getFont(layout, zoom) {
  let fontSize = layout["text-size"](zoom);                                                           let fontFace = layout["text-font"](zoom);
  let lineHeight = layout["text-line-height"](zoom);

  return getFontString(fontFace, fontSize, lineHeight);
}

function initSourceFilter(styles) {
  // Make an [ID, getter] pair for each layer
  const filters = styles.map(parseLayer)
    .map(style => [style.id, makeLayerFilter(style)]);

  return function(source, zoom) {
    const filtered = {};
    filters.forEach(([id, filter]) => {
      let data = filter(source, zoom);
      if (data) filtered[id] = data;
    });
    return filtered; // Dictionary of FeatureCollections, keyed on style.id
  };
}

function makeLayerFilter(style) {
  const minzoom = style.minzoom || 0;
  const maxzoom = style.maxzoom || 99; // NOTE: doesn't allow maxzoom = 0

  const sourceLayer = style["source-layer"];
  //const filter = buildFeatureFilter(style.filter);
  const filter = style.filter;
  const layout = style.layout;
  const interactive = style.interactive;

  const isLabel = style.type === "symbol";
  const compress = (isLabel)
    ? initLabelParser(style)
    : initFeatureGrouper(style);

  return function(source, zoom) {
    // source is a dictionary of FeatureCollections, keyed on source-layer
    if (!source) return false;
    if (zoom < minzoom || maxzoom < zoom) return false;

    let layer = source[sourceLayer];
    if (!layer) return false;

    let features = layer.features.filter(filter);
    if (features.length < 1) return false;

    let compressed = compress(features, zoom);

    let collection = { type: "FeatureCollection", compressed };
    if (interactive) collection.features = features;
    if (isLabel) collection.properties = { font: getFont(layout, zoom) };

    return collection;
  };
}

var read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = (nBytes * 8) - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
};

var write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = (nBytes * 8) - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

var ieee754 = {
	read: read,
	write: write
};

var pbf = Pbf;



function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

// Threshold chosen based on both benchmarking and knowledge about browser string
// data structures (which currently switch structure types at 12 bytes or more)
var TEXT_DECODER_MIN_LENGTH = 12;
var utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf8');

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            this.type = val & 0x7;
            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function(isSigned) {
        var buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;
        b = buf[this.pos];   val |= (b & 0x0f) << 28;

        return readVarintRemainder(val, isSigned, this);
    },

    readVarint64: function() { // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;

        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            // longer strings are fast with the built-in browser TextDecoder API
            return readUtf8TextDecoder(this.buf, pos, end);
        }
        // short strings are fast with our custom implementation
        return readUtf8(this.buf, pos, end);
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readVarint(isSigned));
        return arr;
    },
    readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(l, s, p) {
    var buf = p.buf,
        h, b;

    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ?
        pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return ((high >>> 0) * 0x100000000) + (low >>> 0);
}

function writeBigVarint(val, pbf) {
    var low, high;

    if (val >= 0) {
        low  = (val % 0x100000000) | 0;
        high = (val / 0x100000000) | 0;
    } else {
        low  = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = (low + 1) | 0;
        } else {
            low = 0;
            high = (high + 1) | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos]   = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen =
        len <= 0x3fff ? 1 :
        len <= 0x1fffff ? 2 :
        len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
}

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] * 0x1000000);
}

function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = (val >>> 8);
    buf[pos + 2] = (val >>> 16);
    buf[pos + 3] = (val >>> 24);
}

function readInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
    var str = '';
    var i = pos;

    while (i < end) {
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence =
            b0 > 0xEF ? 4 :
            b0 > 0xDF ? 3 :
            b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) break;

        var b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;

        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function readUtf8TextDecoder(buf, pos, end) {
    return utf8TextDecoder.decode(buf.subarray(pos, end));
}

function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || (i + 1 === str.length)) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}

function classifyRings(rings) {
  // Classifies an array of rings into polygons with outer rings and holes
  if (rings.length <= 1) return [rings];

  var polygons = [];
  var polygon, ccw;

  rings.forEach(ring => {
    let area = signedArea(ring);
    if (area === 0) return;

    if (ccw === undefined) ccw = area < 0;

    if (ccw === area < 0) {
      if (polygon) polygons.push(polygon);
      polygon = [ring];

    } else {
      polygon.push(ring);
    }
  });
  if (polygon) polygons.push(polygon);

  return polygons;
}

function signedArea(ring) {
  const xmul = (p1, p2) => (p2.x - p1.x) * (p1.y + p2.y);

  const initialValue = xmul(ring[0], ring[ring.length - 1]);

  return ring.slice(1)  // NOTE: skips ring[0], shifts index
    .reduce( (sum, p1, i) => sum + xmul(p1, ring[i]), initialValue );
}

function VectorTileFeature(pbf, end, extent, keys, values) {
  // Public
  this.properties = {};
  this.extent = extent;
  this.type = 0;

  // Private
  this._pbf = pbf;
  this._geometry = -1;
  this._keys = keys;
  this._values = values;

  pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
  if (tag == 1) feature.id = pbf.readVarint();
  else if (tag == 2) readTag(pbf, feature);
  else if (tag == 3) feature.type = pbf.readVarint();
  else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
  var end = pbf.readVarint() + pbf.pos;

  while (pbf.pos < end) {
    var key = feature._keys[pbf.readVarint()],
      value = feature._values[pbf.readVarint()];
    feature.properties[key] = value;
  }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
  var pbf = this._pbf;
  pbf.pos = this._geometry;

  var end = pbf.readVarint() + pbf.pos,
    cmd = 1,
    length = 0,
    x = 0,
    y = 0,
    lines = [],
    line;

  while (pbf.pos < end) {
    if (length <= 0) {
      var cmdLen = pbf.readVarint();
      cmd = cmdLen & 0x7;
      length = cmdLen >> 3;
    }

    length--;

    if (cmd === 1 || cmd === 2) {
      x += pbf.readSVarint();
      y += pbf.readSVarint();

      if (cmd === 1) { // moveTo
        if (line) lines.push(line);
        line = [];
      }

      line.push({ x, y });

    } else if (cmd === 7) {
      // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
      if (line) line.push({ // closePolygon
        x: line[0].x,
        y: line[0].y
      });

    } else {
      throw new Error('unknown command ' + cmd);
    }
  }

  if (line) lines.push(line);

  return lines;
};

VectorTileFeature.prototype.bbox = function() {
  var pbf = this._pbf;
  pbf.pos = this._geometry;

  var end = pbf.readVarint() + pbf.pos,
  cmd = 1,
  length = 0,
  x = 0,
  y = 0,
  x1 = Infinity,
  x2 = -Infinity,
  y1 = Infinity,
  y2 = -Infinity;

  while (pbf.pos < end) {
    if (length <= 0) {
      var cmdLen = pbf.readVarint();
      cmd = cmdLen & 0x7;
      length = cmdLen >> 3;
    }

    length--;

    if (cmd === 1 || cmd === 2) {
      x += pbf.readSVarint();
      y += pbf.readSVarint();
      if (x < x1) x1 = x;
      if (x > x2) x2 = x;
      if (y < y1) y1 = y;
      if (y > y2) y2 = y;

    } else if (cmd !== 7) {
      throw new Error('unknown command ' + cmd);
    }
  }

  return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(size, sx = 0, sy = 0) {
  // Input size is the side length of the (square) area over which the
  //  coordinate space of this tile [0, this.extent] will be rendered.
  // Input sx, sy is the origin (top left corner) of the output coordinates
  //  within the (size x size) rendered area of the full tile.

  size = size || this.extent;
  var scale = size / this.extent,
    coords = this.loadGeometry(),
    type = VectorTileFeature.types[this.type];

  function project(line) {
    return line.map(p => [p.x * scale - sx, p.y * scale - sy]);
  }

  switch (type) {
    case "Point":
      coords = project( coords.map(p => p[0]) );
      break;

    case "LineString":
      coords = coords.map(project);
      break;

    case "Polygon":
      coords = classifyRings(coords);
      coords = coords.map(polygon => polygon.map(project));
      break;
  }

  if (coords.length === 1) {
    coords = coords[0];
  } else {
    type = 'Multi' + type;
  }

  var result = {
    type: "Feature",
    geometry: {
      type: type,
      coordinates: coords
    },
    properties: this.properties
  };

  if ('id' in this) result.id = this.id;

  return result;
};

function VectorTileLayer(pbf, end) {
  // Public
  this.version = 1;
  this.name = null;
  this.extent = 4096;
  this.length = 0;

  // Private
  this._pbf = pbf;
  this._keys = [];
  this._values = [];
  this._features = [];

  pbf.readFields(readLayer, this, end);

  this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
  if (tag === 15) layer.version = pbf.readVarint();
  else if (tag === 1) layer.name = pbf.readString();
  else if (tag === 5) layer.extent = pbf.readVarint();
  else if (tag === 2) layer._features.push(pbf.pos);
  else if (tag === 3) layer._keys.push(pbf.readString());
  else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
  var value = null,
  end = pbf.readVarint() + pbf.pos;

  while (pbf.pos < end) {
    var tag = pbf.readVarint() >> 3;

    value = tag === 1 ? pbf.readString() :
      tag === 2 ? pbf.readFloat() :
      tag === 3 ? pbf.readDouble() :
      tag === 4 ? pbf.readVarint64() :
      tag === 5 ? pbf.readVarint() :
      tag === 6 ? pbf.readSVarint() :
      tag === 7 ? pbf.readBoolean() : null;
  }

  return value;
}

// return feature 'i' from this layer as a 'VectorTileFeature'
VectorTileLayer.prototype.feature = function(i) {
  if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

  this._pbf.pos = this._features[i];

  var end = this._pbf.readVarint() + this._pbf.pos;
  return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};

VectorTileLayer.prototype.toGeoJSON = function(size, sx, sy) {
  const features = Array.from(Array(this._features.length), (v, i) => {
    return this.feature(i).toGeoJSON(size, sx, sy);
  });

  return { type: "FeatureCollection", features };
};

function VectorTile(pbf, end) {
  this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
  if (tag === 3) {
    var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
    if (layer.length) layers[layer.name] = layer;
  }
}

function readMVT(dataHref, size, callback) {
  // Input dataHref is the path to a file containing a Mapbox Vector Tile

  return xhrGet(dataHref, "arraybuffer", parseMVT);

  function parseMVT(err, data) {
    if (err) return callback(err, data);
    const tile = new VectorTile(new pbf(data));
    callback(null, mvtToJSON(tile, size));
  }
}

function mvtToJSON(tile, size) {
  const jsonLayers = {};
  Object.values(tile.layers).forEach(layer => {
    jsonLayers[layer.name] = layer.toGeoJSON(size);
  });
  return jsonLayers;
}

function xhrGet(href, type, callback) {
  var req = new XMLHttpRequest();
  req.responseType = type;

  req.onerror = errHandler;
  req.onabort = errHandler;
  req.onload = loadHandler;

  req.open('get', href);
  req.send();

  function errHandler(e) {
    let err = "XMLHttpRequest ended with an " + e.type;
    return callback(err);
  }
  function loadHandler(e) {
    if (req.responseType !== type) {
      let err = "XMLHttpRequest: Wrong responseType. Expected " +
        type + ", got " + req.responseType;
      return callback(err, req.response);
    }
    if (req.status !== 200) {
      let err = "XMLHttpRequest: HTTP " + req.status + " error from " + href;
      return callback(err, req.response);
    }
    return callback(null, req.response);
  }

  return req; // Request can be aborted via req.abort()
}

const tasks = {};
var filter = (data) => data;

onmessage = function(msgEvent) {
  // The message DATA as sent by the parent thread is now a property 
  // of the message EVENT. See
  // https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent
  const { id, type, payload } = msgEvent.data;

  switch (type) {
    case "styles":
      // NOTE: changing global variable!
      filter = initSourceFilter(payload);
      break;
    case "start":
      let callback = (err, result) => sendHeader(id, err, result, payload.zoom);
      let request  = readMVT(payload.href, payload.size, callback);
      tasks[id] = { request, status: "requested" };
      break;
    case "continue":
      sendData(id);
      break;
    case "cancel":
      let task = tasks[id];
      if (task && task.status === "requested") task.request.abort();
      delete tasks[id];
      break;
      // Bad message type!
  }
};

function sendHeader(id, err, result, zoom) {
  // Make sure we still have an active task for this ID
  let task = tasks[id];
  if (!task) return;  // Task must have been canceled

  if (err) {
    delete tasks[id];
    return postMessage({ id, type: "error", payload: err });
  }

  result = filter(result, zoom);
  task.result = result;
  task.layers = Object.keys(result);
  task.status = "parsed";

  // Send a header with info about each layer
  const headers = {};
  task.layers.forEach(key => {
    let data = result[key];
    let header = { compressed: data.compressed.length };
    if (data.features) header.features = data.features.length;
    if (data.properties) header.properties = data.properties;
    headers[key] = header;
  });
  postMessage({ id, type: "header", payload: headers });
}

function sendData(id) {
  // Make sure we still have an active task for this ID
  let task = tasks[id];
  if (!task) return;  // Task must have been canceled

  var currentLayer = task.result[task.layers[0]];
  // Make sure we still have data in this layer
  var dataType = getDataType(currentLayer);
  if (dataType === "none") {
    task.layers.shift();           // Discard this layer
    currentLayer = task.result[task.layers[0]];
    dataType = getDataType(currentLayer);
  }
  if (task.layers.length == 0) {
    delete tasks[id];
    postMessage({ id, type: "done" });
    return;
  }

  // Get the next chunk of data and send it back to the main thread
  var chunk = getChunk(currentLayer[dataType]);
  postMessage({ id, type: dataType, key: task.layers[0], payload: chunk });
}

function getDataType(layer) {
  if (!layer) return "none";
  // All layers have a 'compressed' array
  if (layer.compressed.length > 0) return "compressed";
  // 'compressed' array is empty. There might still be a 'features' array
  if (layer.features && layer.features.length > 0) return "features";
  return "none";
}

function getChunk(arr) {
  // Limit to 100 KB per postMessage. TODO: Consider 10KB for cheap phones? 
  // See https://dassur.ma/things/is-postmessage-slow/
  const maxChunk = 100000; 

  let chunk = [];
  let chunkSize = 0;

  while (arr[0] && chunkSize < maxChunk) {
    let item = arr.shift();
    chunkSize += JSON.stringify(item).length;
    chunk.push(item);
  }

  return chunk;
}
`;

  //const workerPath = "./worker.bundle.js";

  function initTileMixer(userParams) {
    const params = setParams$1(userParams);
    const queue = params.queue;

    // Initialize workers and data prep function getter
    const workerBlob = new Blob([workerCode]);
    const workerPath = URL.createObjectURL(workerBlob);
    const workers = initWorkers(params.threads, workerPath, params.layers);
    const getPrepFuncs = initDataPrep(params.layers);

    // Define request function
    function request({ z, x, y, getPriority, callback }) {
      const reqHandle = {};

      const readInfo = { 
        href: params.getURL(z, x, y),
        size: 512, 
        zoom: z 
      };
      const readTaskId = workers.startTask(readInfo, prepData);
      reqHandle.abort = () => workers.cancelTask(readTaskId);

      function prepData(err, source) {
        if (err) return callback(err);

        const chunks = getPrepFuncs(source, z);
        chunks.push( () => callback(null, source) );

        const prepTaskId = queue.enqueueTask({ getPriority, chunks });
        reqHandle.abort = () => queue.cancelTask(prepTaskId);
      }

      return reqHandle;
    }

    // Return API
    return {
      request,
      activeTasks: () => workers.activeTasks(),
      terminate: () => workers.terminate(),
    };
  }

  function initRasterSource(source) {
    const getURL = initUrlFunc$1(source.tiles);

    function request({z, x, y, callback}) {
      const href = getURL(z, x, y);
      const errMsg = "ERROR in loadImage for href " + href;

      const img = new Image();
      img.onerror = () => callback(errMsg);
      img.onload = () => (img.complete && img.naturalWidth !== 0)
        ? callback(null, img)
        : callback(errMsg);

      img.crossOrigin = "anonymous";
      img.src = href;

      const reqHandle = {};
      reqHandle.abort = () => { img.src = ""; };

      return reqHandle;
    }

    return { request };
  }

  function initUrlFunc$1(endpoints) {
    if (!endpoints || !endpoints.length) fail$1("no valid tile endpoints!");

    // Use a different endpoint for each request
    var index = 0;

    return function(z, x, y) {
      index = (index + 1) % endpoints.length;
      var endpoint = endpoints[index];
      return endpoint.replace(/{z}/, z).replace(/{x}/, x).replace(/{y}/, y);
    };
  }

  function fail$1(message) {
    throw Error("ERROR in raster-source: " + message);
  }

  function initSources(styleDoc, queue, numThreads = 4) {
    const sources = styleDoc.sources;

    // Find the number of Worker threads we can use for each vector source
    const nvec = Object.values(sources).filter(s => s.type === "vector").length;
    const threads = (nvec > 0) ? Math.ceil(numThreads / nvec) : nvec;

    // Initialize a data getter for each source (raster or vector tiles only)
    const getters = {};
    Object.entries(sources).forEach( ([key, source]) => {
      if (!source.tiles || source.tiles.length < 1) return;

      if (source.type === "raster") getters[key] = initRasterSource(source);

      if (source.type !== "vector") return;

      // Vector tiles: Get the layers using this source, and initialize mixer
      let layers = styleDoc.layers.filter(l => l.source === key);
      getters[key] = initTileMixer({ threads, source, layers, queue });
    });

    return function collectSources({ z, x, y, getPriority, callback }) {
      // Collect data from all soures into one object
      const dataCollection = {};
      const loadTasks = {};
      var numToDo = Object.keys(getters).length;

      Object.entries(getters).forEach( ([key, getter]) => {
        loadTasks[key] = getter.request({
          z, x, y, getPriority, 
          callback: (err, data) => collectData(err, key, data),
        });
      });

      function collectData(err, key, data) {
        if (err) console.log(err);

        dataCollection[key] = data;
        delete loadTasks[key];
        if (--numToDo > 0) return;

        return callback(null, dataCollection);
      }

      // Return a handle that allows for cancellation of ongoing tasks
      const handle = {
        cancel: () => Object.values(loadTasks).forEach(task => task.abort()),
      };

      return handle;
    }
  }

  function initTileFactory(styleDoc, canvasSize, queue, nThreads) {

    const getData = initSources(styleDoc, queue, nThreads);

    return function order(z, x, y, callback = () => true) {
      let img = document.createElement("canvas");
      img.width = img.height = canvasSize;

      const tile = {
        z, x, y,
        id: z + "/" + x + "/" + y,
        priority: 0,

        img,
        ctx: img.getContext("2d"),
        rendered: false,
      };

      const loadTask = getData({
        z, x, y,
        getPriority: () => tile.priority,
        callback: addData,
      });

      tile.cancel = () => {
        loadTask.cancel();
        tile.canceled = true;
      };

      function addData(err, data) {
        if (err) console.log(err);
        tile.sources = data;
        tile.loaded = true;
        return callback(null, tile);
      }

      return tile;
    }
  }

  // Renders layers that cover the whole tile (like painting with a roller)

  function initBackgroundFill(layout, paint, canvSize) {
    return function(ctx, zoom) {
      ctx.fillStyle = paint["background-color"](zoom);
      ctx.globalAlpha = paint["background-opacity"](zoom);
      ctx.fillRect(0, 0, canvSize, canvSize);
    }
  }

  function initRasterFill(layout, paint, canvSize) {
    return function(ctx, zoom, image) {
      ctx.globalAlpha = paint["raster-opacity"](zoom);
      // TODO: we are forcing one tile to cover the canvas!
      // In some cases (e.g. Mapbox Satellite Streets) the raster tiles may
      // be half the size of the vector canvas, so we need 4 of them...
      ctx.drawImage(image, 0, 0, canvSize, canvSize);
    }
  }

  function canv(property) {
    // Create a default state setter for a Canvas 2D renderer
    return (val, ctx) => { ctx[property] = val; };
  }

  function pair(getStyle, setState) {
    // Return a style value getter and a renderer state setter as a paired object
    return { getStyle, setState };
  }

  function initBrush({ setters, methods }) {
    const dataFuncs = setters.filter(s => s.getStyle.type === "property");
    const zoomFuncs = setters.filter(s => s.getStyle.type !== "property");

    return function(ctx, zoom, data) {
      // Set the non-data-dependent context state
      zoomFuncs.forEach(f => f.setState(f.getStyle(zoom), ctx));

      // Loop over features and draw
      data.compressed.forEach(feature => drawFeature(ctx, zoom, feature));
    }

    function drawFeature(ctx, zoom, feature) {
      // Set data-dependent context state
      dataFuncs.forEach(f => f.setState(f.getStyle(zoom, feature), ctx));

      // Draw path
      methods.forEach(method => ctx[method](feature.path));
    }
  }

  function makePatternSetter(sprite) {
    return function(spriteID, ctx) {
      const sMeta = sprite.meta[spriteID];
      const patternCanvas = document.createElement("canvas");
      patternCanvas.width = sMeta.width;
      patternCanvas.height = sMeta.height;
      const pCtx = patternCanvas.getContext("2d");
      pCtx.drawImage(
        sprite.image, 
        sMeta.x, 
        sMeta.y, 
        sMeta.width, 
        sMeta.height,
        0,
        0,
        sMeta.width,
        sMeta.height
      );
      ctx.fillStyle = ctx.createPattern(patternCanvas, "repeat");
    };
  }

  function initCircle(layout, paint) {
    const setRadius = (radius, ctx) => ctx.lineWidth = radius * 2;
    const setters = [
      pair(paint["circle-radius"],  setRadius),
      pair(paint["circle-color"],   canv("strokeStyle")),
      pair(paint["circle-opacity"], canv("globalAlpha")),
      pair(() => "round",           canv("lineCap")),
    ];
    const methods = ["stroke"];

    return initBrush({ setters, methods });
  }

  function initLine(layout, paint) {
    const setters = [
      pair(layout["line-cap"],      canv("lineCap")),
      pair(layout["line-join"],     canv("lineJoin")),
      pair(layout["line-miter-limit"], canv("miterLimit")),
      // line-round-limit,

      pair(paint["line-width"],     canv("lineWidth")),
      pair(paint["line-opacity"],   canv("globalAlpha")),
      pair(paint["line-color"],     canv("strokeStyle")),
      // line-gap-width, 
      // line-translate, line-translate-anchor,
      // line-offset, line-blur, line-gradient, line-pattern, 
    ];

    let dasharray = paint["line-dasharray"];
    if (dasharray.type !== "constant" || dasharray() !== undefined) {
      const getWidth = paint["line-width"];
      const getDash = (zoom, feature) => {
        let width = getWidth(zoom, feature);
        let dashes = dasharray(zoom, feature);
        return dashes.map(d => d * width);
      };
      const setDash = (dash, ctx) => ctx.setLineDash(dash);
      setters.push( pair(getDash, setDash) );
    }  const methods = ["stroke"];

    return initBrush({ setters, methods });
  }

  function initFill(layout, paint, sprite) {
    var getStyle, setState;

    let pattern = paint["fill-pattern"];
    if (pattern.type !== "constant" || pattern() !== undefined) {
      // Fill with a repeated sprite. Style getter returns sprite name
      getStyle = pattern;
      setState = makePatternSetter(sprite);
    } else {
      // Fill with a solid color
      getStyle = paint["fill-color"];
      setState = canv("fillStyle");
    }

    const setters = [
      pair(getStyle, setState),
      pair(paint["fill-opacity"],   canv("globalAlpha")),
      pair(paint["fill-translate"], (t, ctx) => ctx.translate(t[0], t[1])),
      // fill-translate-anchor,
    ];
    const methods = ["fill"];

    let outline = paint["fill-outline-color"];
    if (outline.type !== "constant" || outline() !== undefined) {
      setters.push(
        pair(paint["fill-outline-color"], canv("strokeStyle")),
        pair(paint["fill-outline-width"], canv("lineWidth")), // nonstandard
      );
      methods.push("stroke");
    }

    return initBrush({ setters, methods });
  }

  function getTextShift(anchor) {
    // We use the Canvas 2D settings 
    //  textBaseline = "bottom", textAlign = "left"
    // and shift the text box based on the specified "text-anchor"
    // Returned values will be scaled by the text box dimensions
    switch (anchor) {
      case "top-left":
        return [ 0.0, 1.0];
      case "top-right":
        return [-1.0, 1.0];
      case "top":
        return [-0.5, 1.0];
      case "bottom-left":
        return [ 0.0, 0.0];
      case "bottom-right":
        return [-1.0, 0.0];
      case "bottom":
        return [-0.5, 0.0];
      case "left":
        return [ 0.0, 0.5];
      case "right":
        return [-1.0, 0.5];
      case "center":
      default:
        return [-0.5, 0.5];
    }
  }

  function initTextLabeler(ctx, zoom, layout, paint) {
    const fontSize = layout["text-size"](zoom);
    const lineHeight = layout["text-line-height"](zoom);
    const textPadding = layout["text-padding"](zoom);
    const textOffset = layout["text-offset"](zoom);

    ctx.textBaseline = "bottom";
    ctx.textAlign = "left";
    const posShift = getTextShift( layout["text-anchor"](zoom) );

    const haloWidth = paint["text-halo-width"](zoom);
    if (haloWidth > 0) {
      ctx.lineWidth = haloWidth * 2.0;
      ctx.lineJoin = "round";
      ctx.strokeStyle = paint["text-halo-color"](zoom);
    }
    ctx.fillStyle = paint["text-color"](zoom);

    var labelText, labelLength, labelHeight, x, y;

    return { measure, draw };

    function measure(feature) {
      labelText = feature.properties.labelText;
      if (!labelText) return;

      labelLength = feature.properties.textWidth;
      labelHeight = fontSize * lineHeight;

      // Compute coordinates of bottom left corner of text
      var coords = feature.geometry.coordinates;
      x = coords[0] + posShift[0] * labelLength + textOffset[0] * fontSize;
      y = coords[1] + posShift[1] * labelHeight + textOffset[1] * labelHeight;

      // Return a bounding box object
      return [
        [x - textPadding, y - labelHeight - textPadding],
        [x + labelLength + textPadding, y + textPadding]
      ];
    }

    function draw() {
      if (!labelText) return;

      if (haloWidth > 0) ctx.strokeText(labelText, x, y);
      ctx.fillText(labelText, x, y);
    }
  }

  function initIconLabeler(ctx, zoom, layout, paint, sprite) {
    const iconPadding = layout["icon-padding"](zoom);

    var spriteID, spriteMeta, x, y;

    return { measure, draw };

    function measure(feature) {
      spriteID = feature.properties.spriteID;
      if (!spriteID) return;

      spriteMeta = sprite.meta[spriteID];

      var coords = feature.geometry.coordinates;
      x = Math.round(coords[0] - spriteMeta.width / 2);
      y = Math.round(coords[1] - spriteMeta.height / 2);

      return [
        [x - iconPadding, y - iconPadding],
        [x + spriteMeta.width + iconPadding, y + spriteMeta.height + iconPadding]
      ];
    } 

    function draw() {
      if (!spriteID) return;

      ctx.drawImage(
        sprite.image,
        spriteMeta.x,
        spriteMeta.y,
        spriteMeta.width,
        spriteMeta.height,
        x,
        y,
        spriteMeta.width,
        spriteMeta.height
      );
    }
  }

  function initLabeler(layout, paint, sprite, canvasSize) {
    // Skip unsupported symbol types
    if (layout["symbol-placement"]() === "line") return () => undefined;

    const tileBox = [[0, 0], [canvasSize, canvasSize]];

    return function(ctx, zoom, data, boxes) {
      ctx.font = data.properties.font;
      const textLabeler = initTextLabeler(ctx, zoom, layout, paint);
      const iconLabeler = initIconLabeler(ctx, zoom, layout, paint, sprite);

      data.compressed.forEach(drawLabel);

      function drawLabel(feature) {
        var textBox = textLabeler.measure(feature);
        if ( collides(textBox) ) return;

        var iconBox = iconLabeler.measure(feature);
        if ( collides(iconBox) ) return;

        // Draw the labels, IF they are inside the tile
        if ( iconBox && intersects(tileBox, iconBox) ) {
          iconLabeler.draw();
          boxes.push(iconBox);
        }
        if ( textBox && intersects(tileBox, textBox) ) {
          textLabeler.draw();
          boxes.push(textBox);
        }
      }

      function collides(newBox) {
        if (!newBox) return false;
        return boxes.some( box => intersects(box, newBox) );
      }
    }
  }

  function intersects(box1, box2) {
    // box[0] = [xmin, ymin]; box[1] = [xmax, ymax]
    if (box1[0][0] > box2[1][0]) return false;
    if (box2[0][0] > box1[1][0]) return false;
    if (box1[0][1] > box2[1][1]) return false;
    if (box2[0][1] > box1[1][1]) return false;

    return true;
  }

  function getPainter(style, sprite, canvasSize) {
    const painter = makePaintFunction(style, sprite, canvasSize);

    return function(context, zoom, data, boundingBoxes) {
      if (!data) return false;
      if (style.layout.visibility() === "none") return false;

      // Save the initial context state, and restore it after rendering
      context.save();
      painter(context, zoom, data, boundingBoxes);
      context.restore();

      return true; // return value indicates whether canvas has changed
    };
  }

  function makePaintFunction(style, sprite, canvasSize) {
    switch (style.type) {
      case "background":
        return initBackgroundFill(style.layout, style.paint, canvasSize);
      case "raster":
        return initRasterFill(style.layout, style.paint, canvasSize);
      case "symbol":
        return initLabeler(style.layout, style.paint, sprite, canvasSize);
      case "circle":
        return initCircle(style.layout, style.paint);
      case "line":
        return initLine(style.layout, style.paint);
      case "fill":
        return initFill(style.layout, style.paint, sprite);
      case "fill-extrusion":
      case "heatmap":
      case "hillshade":
      default:
        return console.log("ERROR in initRenderer: layer.type = " +
          style.type + " not supported!");
    }
  }

  function initPainter(params) {
    const style = params.styleLayer;
    const canvasSize = params.canvasSize || 512;
    const paint = getPainter(style, params.spriteObject, canvasSize);

    // Define data getter
    const sourceName = style["source"];
    const getData = makeDataGetter(style);

    // Compose data getter and painter into one function
    return function(context, zoom, sources, boundingBoxes) {
      let data = getData(sources[sourceName], zoom);
      return paint(context, zoom, data, boundingBoxes);
    }
  }

  function makeDataGetter(style) {
    // Background layers don't need data
    if (style.type === "background") return () => true;

    const minzoom = style.minzoom || 0;
    const maxzoom = style.maxzoom || 99; // NOTE: doesn't allow maxzoom = 0

    // Raster layers don't need any data processing
    if (style.type === "raster") return function(source, zoom) {
      if (zoom < minzoom || maxzoom < zoom) return false;
      return source;
    }

    return function(source, zoom) {
      if (zoom < minzoom || maxzoom < zoom) return false;
      if (source) return source[style.id];
    };
  }

  function initRenderer$1(styleDoc, canvasSize, queue) {
    const spriteObject = styleDoc.spriteData;

    // Reverse the order of the symbol layers, for correct collision checking
    const labels = styleDoc.layers
      .filter(l => l.type === "symbol");
    const layers = styleDoc.layers
      .filter( l => l.type !== "symbol" )
      .concat( labels.reverse() )
      .map( getStyleFuncs )
      .map( makeLayerFunc );

    function makeLayerFunc(styleLayer) {
      const paint = initPainter({ styleLayer, spriteObject, canvasSize });
      return { paint, id: styleLayer.id, visible: true };
    }

    function setLayerVisibility(id, visibility) {
      var layer = layers.find(l => l.id === id);
      if (layer) layer.visible = visibility;
    }

    function drawLayers(tile, callback) {
      if (tile.canceled) return;
      const bboxes = [];

      layers.forEach(layer => {
        if (!layer.visible) return;
        layer.paint(tile.ctx, tile.z, tile.sources, bboxes);
      });

      tile.rendered = true;
      tile.rendering = false;
      tile.cancel = () => false;

      return callback(null, tile);
    }

    function queueDraw(tile, callback = () => true) {
      if (tile.canceled || !tile.loaded) return;
      if (tile.rendered || tile.rendering) return;

      tile.rendering = true;

      const getPriority = () => tile.priority;
      const chunks = [ () => drawLayers(tile, callback) ];
      const renderTaskId = queue.enqueueTask({ getPriority, chunks });

      tile.cancel = () => { // Is this necessary?
        queue.cancelTask(renderTaskId);
        tile.rendering = false; // TODO: unnecessary?
        tile.canceled = true;
      };
    }

    return {
      draw: queueDraw,
      hideLayer: (id) => setLayerVisibility(id, false),
      showLayer: (id) => setLayerVisibility(id, true),
    };
  }

  function init$2(params) {
    // Process parameters, substituting defaults as needed
    var canvSize = params.size || 512;
    var styleURL = params.style;   // REQUIRED
    var mbToken  = params.token;   // May be undefined
    var nThreads = params.threads || 4;

    // Create dummy API for instant return
    const api = {
      create: () => null,
      redraw: () => null,
      hideLayer: () => null,
      showLayer: () => null,
      sortTasks: () => null,
    };

    // Load the style, and then set everything up
    api.promise = loadStyle(styleURL, mbToken)
      .then( styleDoc => setup(styleDoc, canvSize, nThreads, api) );

    return api;
  }

  function setup(styleDoc, canvSize, nThreads, api) {
    const queue = init$1();
    const orderTile = initTileFactory(styleDoc, canvSize, queue, nThreads);
    const renderer = initRenderer$1(styleDoc, canvSize, queue);

    function create(z, x, y, cb = () => undefined, reportTime) {
      // Wrap the callback to add time reporting
      let t0 = performance.now();

      function orderTimer(err, tile) { // Track ordering time
        if (err) return cb(err);
        let t1 = performance.now();

        function renderTimer(msg, data) { // Track rendering time
          let t2 = performance.now();
          cb(msg, data, t2 - t1, t1 - t0);
        }

        renderer.draw(tile, renderTimer);
      }

      return orderTile(z, x, y, orderTimer);
    }

    // Update api
    api.style = styleDoc;
    api.create = create;
    api.redraw = renderer.draw;
    api.hideLayer = renderer.hideLayer;
    api.showLayer = renderer.showLayer;
    api.sortTasks = queue.sortTasks;

    return api;
  }

  function initCache(size, tileFactory) {
    // Initialize the tiles object
    const tiles = {};
    const getID = tileFactory.getID || ( zxy => zxy.join("/") );

    // Return methods for accessing and updating the tiles
    return {
      retrieve: (zxy) => getTileOrParent(zxy, 0, 0, size),
      process,
      prune,
      trim,
      getPriority: (id) => (tiles[id]) ? tiles[id].priority : undefined,
    };

    function getTileOrParent(
        zxy,        // Coordinates of the requested tile (could be more than 3D)
        sx, sy, sw  // Cropping parameters--which part of the tile to use
        ) {

      // Retrieve the specified tile from the tiles object, add cropping info
      let id = getID(zxy);
      let tile = tiles[id];
      let tilebox = { tile, sx, sy, sw };

      // If the tile exists and is ready, return it (along with the wrapped info)
      if (tile && tile.rendered) return tilebox;

      // Looks like the tile wasn't ready. Try using the parent tile
      if (zxy[0] > 0 && sw > 1) { // Don't look too far back
        let [z, x, y] = zxy;

        // Get coordinates of the parent tile
        let pz = z - 1;
        let px = Math.floor(x / 2);
        let py = Math.floor(y / 2);
        // Copy any additional coordinates beyond the first 3
        let pzxy = [pz, px, py, ...zxy.slice(3)];

        // Compute cropping parameters for the parent
        let psx = sx / 2 + (x / 2 - px) * size;
        let psy = sy / 2 + (y / 2 - py) * size;
        let psw = sw / 2;

        // Get the parent tile. Recursive!
        tilebox = getTileOrParent(pzxy, psx, psy, psw);
      }

      // If the requested tile didn't exist, we need to order it from the factory
      // NOTE: orders are placed AFTER the recursive call for the parent tile,
      // so missing parents will be ordered first
      if (!tile) {
        // For backwards compatibility, assume tileFactory.create still takes
        // a list of coordinates as arguments
        let newTile = tileFactory.create(...zxy);
        if (newTile) tiles[id] = newTile;
      } else if (tileFactory.redraw) {
        // Tile exists but isn't ready. Make sure it is rendering
        tileFactory.redraw(tile);
      }

      return (tilebox && tilebox.tile && tilebox.tile.rendered)
        ? tilebox
        : undefined;
    }

    function process(func) {
      Object.values(tiles).forEach( tile => func(tile) );
    }

    function prune(metric, threshold) {
      // Update tile priorities using the supplied metric. ASSUMES 3 args!
      process(tile => { tile.priority = metric(tile.z, tile.x, tile.y); });
      // Remove tiles where priority is above the threshold
      return drop(threshold);
    }

    function trim(metric, threshold) {
      // Update tile priorities using the supplied metric
      process(tile => { tile.priority = metric(tile); });
      // Remove tiles where priority is above the threshold
      return drop(threshold);
    }

    function drop(threshold) {
      var numTiles = 0;
      for (let id in tiles) {
        if (tiles[id].priority > threshold) {
          tiles[id].cancel();
          delete tiles[id];
        } else {
          numTiles ++;
        }
      }
      return numTiles;
    }
  }

  function setParams(userParams) {
    const params = {};

    params.getTile = userParams.getTile;

    params.tileSize = userParams.tileSize || 512;

    // Get canvas context, and set width/height parameters
    if (userParams.context) {
      params.context = userParams.context;
      params.width = userParams.width || params.context.canvas.width;
      params.height = userParams.height || params.context.canvas.height;
    } else {
      params.context = document.createElement("canvas").getContext("2d");
      params.width = userParams.width || 1024;
      params.height = userParams.height || 1024;
    }

    // Compute number of tiles in each direction.
    params.nx = Math.floor(params.width / params.tileSize);
    params.ny = Math.floor(params.height / params.tileSize);
    if (params.nx * params.tileSize !== params.width ||
        params.ny * params.tileSize !== params.height ) {
      console.log("width, height, tileSize = " +
          params.width + ", " + params.height + ", " + params.tileSize);
      return console.log("ERROR: width, height are not multiples of tileSize!!");
    }
    console.log("map size: " + params.width + "x" + params.height);

    // Define a min zoom (if not supplied), such that there are always enough
    // tiles to cover the grid without repeating
    params.minZoom = (userParams.minZoom === undefined)
      ? Math.floor( Math.min(Math.log2(params.nx), Math.log2(params.ny)) )
      : Math.max(0, Math.floor(userParams.minZoom));
    // Make sure any supplied max zoom is an integer larger than minZoom
    params.maxZoom = (userParams.maxZoom === undefined)
      ? 22
      : Math.max(params.minZoom, Math.floor(userParams.maxZoom));
    // Make sure initial zoom is an integer within range
    params.zoom = (userParams.zoom === undefined)
      ? params.minZoom
      : Math.floor(userParams.zoom);
    params.zoom = Math.min(Math.max(params.minZoom, params.zoom), params.maxZoom);

    // Set the initial center of the map
    params.center = userParams.center || [0.5, 0.5], // X, Y in map coordinates
    params.center[0] = Math.min(Math.max(0.0, params.center[0]), 1.0);
    params.center[1] = Math.min(Math.max(0.0, params.center[1]), 1.0);

    return params;
  }

  function initBoundingBox(params, setCenterZoom) {

    return function fitBoundingBox(p1, p2) {
      // Inputs p1, p2 are 2D arrays containing pairs of X/Y coordinates
      // in the range [0,1] X [0,1] with (0,0) at the top left corner.
      // ASSUMES p2 is SouthEast of p1 although we may have p2[0] < p1[0]
      // if the box crosses the antimeridian (longitude = +/- PI)

      // Compute box width and height, with special handling for antimeridian
      var boxWidth = p2[0] - p1[0];
      if (boxWidth < 0) boxWidth += 1.0; // Crossing antimeridian
      var boxHeight = p2[1] - p1[1];
      if (boxHeight < 0) return false;

      // Calculate the maximum zoom level at which the bounding box will fit
      // within the map. Note: we want to be able to pan without having to change
      // zoom. Hence the bounding box must always fit within gridSize - 1.

      // Width/height of a tile: 1 / 2 ** zoom. Hence we need
      //  (numTiles - 1) / 2 ** zoom > boxSize in both X and Y
      var zoomX = Math.log2( (params.nx - 1) / boxWidth );
      var zoomY = Math.log2( (params.ny - 1) / boxHeight );

      // Compute the coordinates of the center of the box
      var centerX = (p1[0] + boxWidth / 2.0);
      if (centerX > 1) centerX -= 1;
      var centerY = 0.5 * (p1[1] + p2[1]);

      return setCenterZoom( [centerX, centerY], Math.min(zoomX, zoomY) );
    }
  }

  function initTileCoords( params ) {
    // TODO: verify code for non-Mercator projections. Assumes x is periodic

    var zoom, nTiles, xTile0, yTile0;
    const origin = new Float64Array(2);
    const scale = new Float64Array(2);

    // Set initial values
    setCenterZoom(params.center, params.zoom);

    return {
      // Methods to report info about current map state
      getScale: (i) => scale[i],
      getZXY,

      // Methods to compute positions within current map
      toLocal,
      xyToMapPixels,

      // Methods to update map state
      setCenterZoom,
      fitBoundingBox: initBoundingBox(params, setCenterZoom),
      move,
    };

    function getZXY(zxy, ix, iy) {
      // Report the ZXY of a given tile within the grid
      zxy[0] = zoom;
      zxy[1] = wrap(xTile0 + ix, nTiles);
      zxy[2] = wrap(yTile0 + iy, nTiles);
    }

    function toLocal(local, global) {
      // TODO: wrapping is problematic
      local[0] = wrap(global[0] - origin[0], 1.0) * scale[0];
      local[1] = (global[1] - origin[1]) * scale[1];
    }

    function xyToMapPixels(local, global) {
      toLocal(local, global);
      local[0] *= params.width;
      local[1] *= params.height;
    }

    function setCenterZoom(center, zNew) {
      // 1. Make sure the supplied zoom is within range and an integer
      zNew = Math.min(Math.max(params.minZoom, zNew), params.maxZoom);
      zNew = Math.floor(zNew); // TODO: should this be Math.round() ?
      var nTnew = 2 ** zNew; // Number of tiles at this zoom level

      // 2. Find the integer tile numbers of the top left corner of the rectangle
      //    whose center will be within 1/2 tile of (centerX, centerY)
      var x0new = Math.round(center[0] * nTnew - params.nx / 2.0);
      x0new = wrap(x0new, nTnew); // in case we crossed the antimeridian

      var y0new = Math.round(center[1] * nTnew - params.ny / 2.0);
      y0new = Math.min(Math.max(0, y0new), nTnew - params.ny); // Don't cross pole

      // 3. Return a flag indicating whether map parameters were updated
      return updateTransform(zNew, x0new, y0new);
    }

    function move(dz, dx, dy) {
      var dzi = Math.round(dz);
      var dxi = Math.round(dx);
      var dyi = Math.round(dy);

      // Panning first
      var x0new = wrap(xTile0 + dxi, nTiles);
      var y0new = wrap(yTile0 + dyi, nTiles);

      var zNew = zoom;
      while (dzi > 0 && zNew < params.maxZoom) {  // Zoom in
        zNew++;
        x0new = Math.floor(2 * x0new + params.nx / 2.0);
        y0new = Math.floor(2 * y0new + params.ny / 2.0);
        dzi--;
      }
      while (dzi < 0 && zNew > params.minZoom) {  // Zoom out
        zNew--;
        x0new = wrap( Math.ceil( (x0new - params.nx / 2.0) / 2 ), 2 ** zNew );
        y0new = wrap( Math.ceil( (y0new - params.ny / 2.0) / 2 ), 2 ** zNew );
        dzi++;
      }

      return updateTransform(zNew, x0new, y0new);
    }

    function updateTransform(zNew, x0new, y0new) {
      if (zNew === zoom && x0new === xTile0 && y0new === yTile0) return false;

      zoom = zNew;
      xTile0 = x0new;
      yTile0 = y0new;

      nTiles = 2 ** zoom;
      origin[0] = xTile0 / nTiles;
      origin[1] = yTile0 / nTiles;
      scale[0] = nTiles / params.nx; // Problematic if < 1 ?
      scale[1] = nTiles / params.ny;

      return true;
    }
  }

  function wrap(x, xmax) {
    while (x < 0) x += xmax;
    while (x >= xmax) x -= xmax;
    return x;
  }

  function initRenderer(params) {
    const context = params.context;
    const size = params.tileSize;

    // Resize drawingbuffer to fit the specified number of tiles
    context.canvas.width = params.width;
    context.canvas.height = params.height;

    return {
      draw,
      clear,
    };

    function clear() {
      return context.clearRect(0, 0, params.width, params.height);
    }

    function draw(tilebox, ix, iy) {
      context.drawImage(
          tilebox.tile.img,  // Image to read, and paint to the canvas
          tilebox.sx,        // First x-pixel in tile to read
          tilebox.sy,        // First y-pixel in tile to read
          tilebox.sw,        // Number of pixels to read in x
          tilebox.sw,        // Number of pixels to read in y
          ix * size,         // First x-pixel in canvas to paint
          iy * size,         // First y-pixel in canvas to paint
          size,              // Number of pixels to paint in x
          size               // Number of pixels to paint in y
          );
      return;
    }
  }

  function initGrid(params, coords, renderer) {
    const boxes = Array.from(Array(params.ny), () => []);

    const oneTileComplete = 1. / params.nx / params.ny;
    var complete = 0.0;

    return {
      loaded: () => complete,
      getBox: (ix, iy) => (boxes[iy]) ? boxes[iy][ix] : undefined,
      drawTiles,
      reset,
    };

    function drawTiles() {
      var updated = false;
      if (complete === 1.0) return updated; // Map is complete, no change!
      const zxy = [];

      for (let iy = 0; iy < params.ny; iy++) {
        var row = boxes[iy];
        for (let ix = 0; ix < params.nx; ix++) {
          coords.getZXY(zxy, ix, iy);
          var currentZ = (row[ix]) 
            ? row[ix].tile.z
            : undefined;
          if (currentZ === zxy[0]) continue; // This tile already done

          var newbox = params.getTile( zxy );
          if (!newbox) continue; // No image available for this tile
          if (newbox.tile.z === currentZ) continue; // Tile already written

          row[ix] = newbox;
          renderer.draw(newbox, ix, iy);
          updated = true;

          if (newbox.tile.z === zxy[0]) complete += oneTileComplete;
        }
      }
      return updated;
    }

    function reset() {
      boxes.forEach(row => { row.length = 0; });
      complete = 0.0;
    }
  }

  function initTileMetric(params, getZXY) {
    const zxy = [];

    return function(tile) {
      // Get distances of the tile from the current map
      let dist = getDiffs(tile);
      
      // Use the largest horizontal distance, and adjust for zoom difference
      return Math.max(dist.dx, dist.dy) - 1.0 + 1.0 / 2 ** dist.dz;
    }

    function getDiffs(tile) {
      // Store coordinates of the corners of the map
      getZXY(zxy, 0, 0);
      let mb = {
        x1: zxy[1],
        x2: zxy[1] + params.nx + 1, // Note: may extend across antimeridian!
        y1: zxy[2],
        y2: zxy[2] + params.ny + 1,
      };

      // Store tile corners. Convert x, y to equivalent values at MAP zoom level
      let dz = zxy[0] - tile.z;
      let zoomFac = 2 ** dz;
      let tb = {
        x1: tile.x * zoomFac,
        x2: (tile.x + 1) * zoomFac,
        y1: tile.y * zoomFac,
        y2: (tile.y + 1) * zoomFac,
      };

      // Find horizontal distance between current tile and edges of current map
      //  hdist < 0: part of input tile is within map
      //  hdist = 0: tile edge touches edge of map
      //  hdist = n: tile edge is n tiles away from edge of map,
      let nTiles = 2 ** zxy[0];
      let dx = Math.min( // Be careful with the antimeridian
        // Test for non-intersection with tile in raw position
        Math.max(mb.x1 - tb.x2, tb.x1 - mb.x2),
        // Re-test with tile shifted across antimeridian
        Math.max(mb.x1 - (tb.x2 + nTiles), tb.x1 + nTiles - mb.x2)
      );
      let dy = Math.max(mb.y1 - tb.y2, tb.y1 - mb.y2);

      return { dz, dx, dy };
    }
  }

  function init(userParams) {
    const params = setParams(userParams);
    if (!params) return;

    const coords = initTileCoords(params);
    const renderer = initRenderer(params);
    const grid = initGrid(params, coords, renderer);

    return {
      canvas: params.context.canvas,

      // Report status or data
      loaded: grid.loaded,
      getTilePos,
      // Methods to clear or update the canvas
      reset: grid.reset,
      clear,
      drawTiles: grid.drawTiles,

      // Coordinate methods to set the position and zoom of the map
      move:       (dz, dx, dy) => { if (coords.move(dz, dx, dy))       clear(); },
      fitBoundingBox: (p1, p2) => { if (coords.fitBoundingBox(p1, p2)) clear(); },
      setCenterZoom:    (c, z) => { if (coords.setCenterZoom(c, z))    clear(); },

      // Methods to convert coordinates, or report conversion parameters
      toLocal:       coords.toLocal,
      xyToMapPixels: coords.xyToMapPixels,
      getScale:      coords.getScale,

      // Metric to evaluate distance of a tile from the current grid
      tileDistance: initTileMetric(params, coords.getZXY),
    };

    function getTilePos(mapXY) {
      // Get indices to the tile box
      let fx = mapXY[0] / params.tileSize;
      let fy = mapXY[1] / params.tileSize;
      let ix = Math.floor(fx);
      let iy = Math.floor(fy);

      // Get the tile box itself
      let box = grid.getBox(ix, iy);
      if (!box) return;

      // Compute position and scaling within the tile
      let x = (fx - ix) * box.sw + box.sx;
      let y = (fy - iy) * box.sw + box.sy;
      let frac = box.sw / params.tileSize; // Fraction of the tile being used

      // Return the tile along with the projected position and scaling info
      return { x, y, frac, tile: box.tile };
    }

    function clear() { // TODO: Do we ever need grid.reset without clear?
      grid.reset();
      renderer.clear();
    }
  }

  const params = {
    // URL of a Mapbox Style document
    style: "./macrostrat-grouped.json",

    // Token, for expanding Mapbox shorthand URLs
    token: "pk.eyJ1IjoiamhlbWJkIiwiYSI6ImNqcHpueHpyZjBlMjAzeG9kNG9oNzI2NTYifQ.K7fqhk2Z2YZ8NIV94M-5nA",
    
    // Number of zoom levels
    maxZoom: 20,
    
    // Width of a tile in pixels (ASSUMES square tiles)
    tileSize: 512,
    
    // Size of map to display, in pixels
    width: 1024,
    height: 1024,

    // Initial center and zoom
    center: [0.21875, 0.40625],
    zoom: 5,
  };

  function initCursor() {
    // What does an animation need to know about the cursor at each frame?
    // First, whether the user did any of the following since the last frame:
    //  - Started new actions
    let touchStarted = false; // Touched or clicked the element
    let zoomStarted  = false; // Rotated mousewheel, or started two-finger touch
    //  - Changed something
    let moved  = false;       // Moved mouse or touch point
    let zoomed = false;       // Rotated mousewheel, or adjusted two-finger touch
    //  - Is potentially in the middle of something
    let tapping = false;      // No touchEnd, and no cursor motion
    //  - Ended actions
    let touchEnded = false;   // mouseup or touchend/cancel/leave
    let tapped = false;       // Completed a click or tap action

    // We also need to know the current cursor position and zoom scale
    let cursorX = 0;
    let cursorY = 0;
    let zscale = 1.0;

    // For tap/click reporting, we need to remember where the touch started
    let startX = 0;
    let startY = 0;
    // What is a click/tap and what is a drag? If the cursor moved more than
    // this threshold between touchStart and touchEnd, it is a drag
    const threshold = 6;

    return {
      // Methods to report local state. Return a copy to protect local values
      touchStarted: () => touchStarted,
      zoomStarted: () => zoomStarted,
      moved: () => moved,
      zoomed: () => zoomed,
      tapped: () => tapped,
      touchEnded: () => touchEnded,
      hasChanged: () => (moved || zoomed || tapped),
      zscale: () => zscale,
      x: () => cursorX,
      y: () => cursorY,

      // Methods to update local state
      startTouch,
      startZoom,
      move,
      zoom,
      endTouch,
      reset,
    };

    function startTouch(evnt) {
      cursorX = evnt.clientX;
      cursorY = evnt.clientY;
      touchStarted = true;
      startX = cursorX;
      startY = cursorY;
      tapping = true;
    }

    function startZoom(evnt) {
      // Store the cursor position
      cursorX = evnt.clientX;
      cursorY = evnt.clientY;
      zoomStarted = true;
      tapping = false;
    }

    function move(evnt) {
      cursorX = evnt.clientX;
      cursorY = evnt.clientY;
      moved = true;
      const dist = Math.hypot(cursorX - startX, cursorY - startY);
      if (dist > threshold) tapping = false;
    }

    function zoom(scale) {
      zscale *= scale;
      zoomed = true;
      tapping = false;
    }

    function endTouch() {
      if (touchStarted) {
        // Ending a new touch? Just ignore both // TODO: is this a good idea?
        touchStarted = false;
        touchEnded = false;
      } else {
        touchEnded = true;
      }
      tapped = tapping;
      tapping = false;
    }

    function reset() {
      touchStarted = false;
      zoomStarted  = false;
      moved  = false;
      zoomed = false;
      touchEnded = false;
      // NOTE: we do NOT reset tapping... this could carry over to next check
      tapped = false;
      zscale = 1.0;
    }
  }

  function getMidPoint(p0, p1) {
    // Convert a two-touch event to a single event at the midpoint
    const dx = p1.clientX - p0.clientX;
    const dy = p1.clientY - p0.clientY;
    return {
      clientX: p0.clientX + dx / 2,
      clientY: p0.clientY + dy / 2,
      distance: Math.hypot(dx, dy),
    };
  }

  function initWheelScale(wheelDelta) {
    return (wheelDelta === "constant") ? wheelScale_const : wheelScale;
  }

  function wheelScale(turn) {
    const { deltaY, deltaMode } = turn;
    if (!deltaY) return 1.0; // Could be a deltaX or deltaZ event

    switch (deltaMode) {
      case 0:
        // Chrome on Windows 10 Surface Book 2: deltaY = -100 * devicePixelRatio
        return 1.0 + deltaY * 0.002 / window.devicePixelRatio;
      case 1:
        // Firefox on Windows 10 Surface Book 2: deltaY = -3
        return 1.0 + deltaY * 0.067;
      case 2:
        // Untested. Ratio vs. case 0 is from d3-zoom
        return 1.0 + deltaY;
    }
  }

  function wheelScale_const(turn) {
    // Ignore dY from the browser - may be arbitrarily scaled. Keep only the sign
    return 1.0 + 0.2 * Math.sign(turn.deltaY);
  }

  function initTouch(div, { wheelDelta = "default" } = {}) {
    // Add event listeners to update the state of a cursor object
    // Input div is an HTML element on which events will be registered
    const cursor = initCursor();
    const getWheelScale = initWheelScale(wheelDelta);

    // Remember the distance between two pointers
    let lastDistance = 1.0;

    div.addEventListener("dragstart", d => d.preventDefault(), false);

    // Add mouse events
    div.addEventListener("mousedown",   cursor.startTouch, false);
    div.addEventListener("mousemove",   cursor.move,       false);
    div.addEventListener("mouseup",     cursor.endTouch,   false);
    div.addEventListener("mouseleave",  cursor.endTouch,   false);
    div.addEventListener("wheel",       wheelZoom,         false);

    // Add touch events
    div.addEventListener("touchstart",  initTouch,       false);
    div.addEventListener("touchmove",   moveTouch,       false);
    div.addEventListener("touchend",    cursor.endTouch, false);
    div.addEventListener("touchcancel", cursor.endTouch, false);

    return cursor;

    function initTouch(evnt) {
      const { touches } = evnt;
      evnt.preventDefault();
      switch (touches.length) {
        case 1:
          cursor.startTouch(touches[0]);
          break;
        case 2: {
          const midpoint = getMidPoint(touches[0], touches[1]);
          cursor.startTouch(midpoint);
          cursor.startZoom(midpoint);
          // Initialize the starting distance between touches
          lastDistance = midpoint.distance;
          break;
        }
        default:
          cursor.endTouch(evnt);
      }
    }

    function moveTouch(evnt) {
      const { touches } = evnt;
      evnt.preventDefault();
      // NOTE: MDN says to add the touchmove handler within the touchstart handler
      // https://developer.mozilla.org/en-US/docs/Web/API/Touch_events/Using_Touch_Events
      switch (touches.length) {
        case 1:
          cursor.move(touches[0]);
          break;
        case 2: {
          const midpoint = getMidPoint(touches[0], touches[1]);
          // Move the cursor to the midpoint
          cursor.move(midpoint);
          // Zoom based on the change in distance between the two touches
          cursor.zoom(lastDistance / midpoint.distance);
          // Remember the new touch distance
          lastDistance = midpoint.distance;
          break;
        }
        default:
          return false;
      }
    }

    function wheelZoom(turn) {
      turn.preventDefault();
      cursor.startZoom(turn);
      cursor.zoom(getWheelScale(turn));
    }
  }

  var booleanPointInPolygon$1 = {};

  var invariant = {};

  var helpers = {};

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  /**
   * @module helpers
   */
  /**
   * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
   *
   * @memberof helpers
   * @type {number}
   */
  exports.earthRadius = 6371008.8;
  /**
   * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
   *
   * @memberof helpers
   * @type {Object}
   */
  exports.factors = {
      centimeters: exports.earthRadius * 100,
      centimetres: exports.earthRadius * 100,
      degrees: exports.earthRadius / 111325,
      feet: exports.earthRadius * 3.28084,
      inches: exports.earthRadius * 39.370,
      kilometers: exports.earthRadius / 1000,
      kilometres: exports.earthRadius / 1000,
      meters: exports.earthRadius,
      metres: exports.earthRadius,
      miles: exports.earthRadius / 1609.344,
      millimeters: exports.earthRadius * 1000,
      millimetres: exports.earthRadius * 1000,
      nauticalmiles: exports.earthRadius / 1852,
      radians: 1,
      yards: exports.earthRadius / 1.0936,
  };
  /**
   * Units of measurement factors based on 1 meter.
   *
   * @memberof helpers
   * @type {Object}
   */
  exports.unitsFactors = {
      centimeters: 100,
      centimetres: 100,
      degrees: 1 / 111325,
      feet: 3.28084,
      inches: 39.370,
      kilometers: 1 / 1000,
      kilometres: 1 / 1000,
      meters: 1,
      metres: 1,
      miles: 1 / 1609.344,
      millimeters: 1000,
      millimetres: 1000,
      nauticalmiles: 1 / 1852,
      radians: 1 / exports.earthRadius,
      yards: 1 / 1.0936,
  };
  /**
   * Area of measurement factors based on 1 square meter.
   *
   * @memberof helpers
   * @type {Object}
   */
  exports.areaFactors = {
      acres: 0.000247105,
      centimeters: 10000,
      centimetres: 10000,
      feet: 10.763910417,
      inches: 1550.003100006,
      kilometers: 0.000001,
      kilometres: 0.000001,
      meters: 1,
      metres: 1,
      miles: 3.86e-7,
      millimeters: 1000000,
      millimetres: 1000000,
      yards: 1.195990046,
  };
  /**
   * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
   *
   * @name feature
   * @param {Geometry} geometry input geometry
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature} a GeoJSON Feature
   * @example
   * var geometry = {
   *   "type": "Point",
   *   "coordinates": [110, 50]
   * };
   *
   * var feature = turf.feature(geometry);
   *
   * //=feature
   */
  function feature(geom, properties, options) {
      if (options === void 0) { options = {}; }
      var feat = { type: "Feature" };
      if (options.id === 0 || options.id) {
          feat.id = options.id;
      }
      if (options.bbox) {
          feat.bbox = options.bbox;
      }
      feat.properties = properties || {};
      feat.geometry = geom;
      return feat;
  }
  exports.feature = feature;
  /**
   * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
   * For GeometryCollection type use `helpers.geometryCollection`
   *
   * @name geometry
   * @param {string} type Geometry Type
   * @param {Array<any>} coordinates Coordinates
   * @param {Object} [options={}] Optional Parameters
   * @returns {Geometry} a GeoJSON Geometry
   * @example
   * var type = "Point";
   * var coordinates = [110, 50];
   * var geometry = turf.geometry(type, coordinates);
   * // => geometry
   */
  function geometry(type, coordinates, options) {
      switch (type) {
          case "Point": return point(coordinates).geometry;
          case "LineString": return lineString(coordinates).geometry;
          case "Polygon": return polygon(coordinates).geometry;
          case "MultiPoint": return multiPoint(coordinates).geometry;
          case "MultiLineString": return multiLineString(coordinates).geometry;
          case "MultiPolygon": return multiPolygon(coordinates).geometry;
          default: throw new Error(type + " is invalid");
      }
  }
  exports.geometry = geometry;
  /**
   * Creates a {@link Point} {@link Feature} from a Position.
   *
   * @name point
   * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature<Point>} a Point feature
   * @example
   * var point = turf.point([-75.343, 39.984]);
   *
   * //=point
   */
  function point(coordinates, properties, options) {
      if (options === void 0) { options = {}; }
      var geom = {
          type: "Point",
          coordinates: coordinates,
      };
      return feature(geom, properties, options);
  }
  exports.point = point;
  /**
   * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
   *
   * @name points
   * @param {Array<Array<number>>} coordinates an array of Points
   * @param {Object} [properties={}] Translate these properties to each Feature
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
   * associated with the FeatureCollection
   * @param {string|number} [options.id] Identifier associated with the FeatureCollection
   * @returns {FeatureCollection<Point>} Point Feature
   * @example
   * var points = turf.points([
   *   [-75, 39],
   *   [-80, 45],
   *   [-78, 50]
   * ]);
   *
   * //=points
   */
  function points(coordinates, properties, options) {
      if (options === void 0) { options = {}; }
      return featureCollection(coordinates.map(function (coords) {
          return point(coords, properties);
      }), options);
  }
  exports.points = points;
  /**
   * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
   *
   * @name polygon
   * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature<Polygon>} Polygon Feature
   * @example
   * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
   *
   * //=polygon
   */
  function polygon(coordinates, properties, options) {
      if (options === void 0) { options = {}; }
      for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
          var ring = coordinates_1[_i];
          if (ring.length < 4) {
              throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
          }
          for (var j = 0; j < ring[ring.length - 1].length; j++) {
              // Check if first point of Polygon contains two numbers
              if (ring[ring.length - 1][j] !== ring[0][j]) {
                  throw new Error("First and last Position are not equivalent.");
              }
          }
      }
      var geom = {
          type: "Polygon",
          coordinates: coordinates,
      };
      return feature(geom, properties, options);
  }
  exports.polygon = polygon;
  /**
   * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
   *
   * @name polygons
   * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the FeatureCollection
   * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
   * @example
   * var polygons = turf.polygons([
   *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
   *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
   * ]);
   *
   * //=polygons
   */
  function polygons(coordinates, properties, options) {
      if (options === void 0) { options = {}; }
      return featureCollection(coordinates.map(function (coords) {
          return polygon(coords, properties);
      }), options);
  }
  exports.polygons = polygons;
  /**
   * Creates a {@link LineString} {@link Feature} from an Array of Positions.
   *
   * @name lineString
   * @param {Array<Array<number>>} coordinates an array of Positions
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature<LineString>} LineString Feature
   * @example
   * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
   * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
   *
   * //=linestring1
   * //=linestring2
   */
  function lineString(coordinates, properties, options) {
      if (options === void 0) { options = {}; }
      if (coordinates.length < 2) {
          throw new Error("coordinates must be an array of two or more positions");
      }
      var geom = {
          type: "LineString",
          coordinates: coordinates,
      };
      return feature(geom, properties, options);
  }
  exports.lineString = lineString;
  /**
   * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
   *
   * @name lineStrings
   * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
   * associated with the FeatureCollection
   * @param {string|number} [options.id] Identifier associated with the FeatureCollection
   * @returns {FeatureCollection<LineString>} LineString FeatureCollection
   * @example
   * var linestrings = turf.lineStrings([
   *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
   *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
   * ]);
   *
   * //=linestrings
   */
  function lineStrings(coordinates, properties, options) {
      if (options === void 0) { options = {}; }
      return featureCollection(coordinates.map(function (coords) {
          return lineString(coords, properties);
      }), options);
  }
  exports.lineStrings = lineStrings;
  /**
   * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
   *
   * @name featureCollection
   * @param {Feature[]} features input features
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {FeatureCollection} FeatureCollection of Features
   * @example
   * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
   * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
   * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
   *
   * var collection = turf.featureCollection([
   *   locationA,
   *   locationB,
   *   locationC
   * ]);
   *
   * //=collection
   */
  function featureCollection(features, options) {
      if (options === void 0) { options = {}; }
      var fc = { type: "FeatureCollection" };
      if (options.id) {
          fc.id = options.id;
      }
      if (options.bbox) {
          fc.bbox = options.bbox;
      }
      fc.features = features;
      return fc;
  }
  exports.featureCollection = featureCollection;
  /**
   * Creates a {@link Feature<MultiLineString>} based on a
   * coordinate array. Properties can be added optionally.
   *
   * @name multiLineString
   * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature<MultiLineString>} a MultiLineString feature
   * @throws {Error} if no coordinates are passed
   * @example
   * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
   *
   * //=multiLine
   */
  function multiLineString(coordinates, properties, options) {
      if (options === void 0) { options = {}; }
      var geom = {
          type: "MultiLineString",
          coordinates: coordinates,
      };
      return feature(geom, properties, options);
  }
  exports.multiLineString = multiLineString;
  /**
   * Creates a {@link Feature<MultiPoint>} based on a
   * coordinate array. Properties can be added optionally.
   *
   * @name multiPoint
   * @param {Array<Array<number>>} coordinates an array of Positions
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature<MultiPoint>} a MultiPoint feature
   * @throws {Error} if no coordinates are passed
   * @example
   * var multiPt = turf.multiPoint([[0,0],[10,10]]);
   *
   * //=multiPt
   */
  function multiPoint(coordinates, properties, options) {
      if (options === void 0) { options = {}; }
      var geom = {
          type: "MultiPoint",
          coordinates: coordinates,
      };
      return feature(geom, properties, options);
  }
  exports.multiPoint = multiPoint;
  /**
   * Creates a {@link Feature<MultiPolygon>} based on a
   * coordinate array. Properties can be added optionally.
   *
   * @name multiPolygon
   * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature<MultiPolygon>} a multipolygon feature
   * @throws {Error} if no coordinates are passed
   * @example
   * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
   *
   * //=multiPoly
   *
   */
  function multiPolygon(coordinates, properties, options) {
      if (options === void 0) { options = {}; }
      var geom = {
          type: "MultiPolygon",
          coordinates: coordinates,
      };
      return feature(geom, properties, options);
  }
  exports.multiPolygon = multiPolygon;
  /**
   * Creates a {@link Feature<GeometryCollection>} based on a
   * coordinate array. Properties can be added optionally.
   *
   * @name geometryCollection
   * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
   * @example
   * var pt = turf.geometry("Point", [100, 0]);
   * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
   * var collection = turf.geometryCollection([pt, line]);
   *
   * // => collection
   */
  function geometryCollection(geometries, properties, options) {
      if (options === void 0) { options = {}; }
      var geom = {
          type: "GeometryCollection",
          geometries: geometries,
      };
      return feature(geom, properties, options);
  }
  exports.geometryCollection = geometryCollection;
  /**
   * Round number to precision
   *
   * @param {number} num Number
   * @param {number} [precision=0] Precision
   * @returns {number} rounded number
   * @example
   * turf.round(120.4321)
   * //=120
   *
   * turf.round(120.4321, 2)
   * //=120.43
   */
  function round(num, precision) {
      if (precision === void 0) { precision = 0; }
      if (precision && !(precision >= 0)) {
          throw new Error("precision must be a positive number");
      }
      var multiplier = Math.pow(10, precision || 0);
      return Math.round(num * multiplier) / multiplier;
  }
  exports.round = round;
  /**
   * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
   * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
   *
   * @name radiansToLength
   * @param {number} radians in radians across the sphere
   * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
   * meters, kilometres, kilometers.
   * @returns {number} distance
   */
  function radiansToLength(radians, units) {
      if (units === void 0) { units = "kilometers"; }
      var factor = exports.factors[units];
      if (!factor) {
          throw new Error(units + " units is invalid");
      }
      return radians * factor;
  }
  exports.radiansToLength = radiansToLength;
  /**
   * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
   * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
   *
   * @name lengthToRadians
   * @param {number} distance in real units
   * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
   * meters, kilometres, kilometers.
   * @returns {number} radians
   */
  function lengthToRadians(distance, units) {
      if (units === void 0) { units = "kilometers"; }
      var factor = exports.factors[units];
      if (!factor) {
          throw new Error(units + " units is invalid");
      }
      return distance / factor;
  }
  exports.lengthToRadians = lengthToRadians;
  /**
   * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
   * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
   *
   * @name lengthToDegrees
   * @param {number} distance in real units
   * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
   * meters, kilometres, kilometers.
   * @returns {number} degrees
   */
  function lengthToDegrees(distance, units) {
      return radiansToDegrees(lengthToRadians(distance, units));
  }
  exports.lengthToDegrees = lengthToDegrees;
  /**
   * Converts any bearing angle from the north line direction (positive clockwise)
   * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
   *
   * @name bearingToAzimuth
   * @param {number} bearing angle, between -180 and +180 degrees
   * @returns {number} angle between 0 and 360 degrees
   */
  function bearingToAzimuth(bearing) {
      var angle = bearing % 360;
      if (angle < 0) {
          angle += 360;
      }
      return angle;
  }
  exports.bearingToAzimuth = bearingToAzimuth;
  /**
   * Converts an angle in radians to degrees
   *
   * @name radiansToDegrees
   * @param {number} radians angle in radians
   * @returns {number} degrees between 0 and 360 degrees
   */
  function radiansToDegrees(radians) {
      var degrees = radians % (2 * Math.PI);
      return degrees * 180 / Math.PI;
  }
  exports.radiansToDegrees = radiansToDegrees;
  /**
   * Converts an angle in degrees to radians
   *
   * @name degreesToRadians
   * @param {number} degrees angle between 0 and 360 degrees
   * @returns {number} angle in radians
   */
  function degreesToRadians(degrees) {
      var radians = degrees % 360;
      return radians * Math.PI / 180;
  }
  exports.degreesToRadians = degreesToRadians;
  /**
   * Converts a length to the requested unit.
   * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
   *
   * @param {number} length to be converted
   * @param {Units} [originalUnit="kilometers"] of the length
   * @param {Units} [finalUnit="kilometers"] returned unit
   * @returns {number} the converted length
   */
  function convertLength(length, originalUnit, finalUnit) {
      if (originalUnit === void 0) { originalUnit = "kilometers"; }
      if (finalUnit === void 0) { finalUnit = "kilometers"; }
      if (!(length >= 0)) {
          throw new Error("length must be a positive number");
      }
      return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
  }
  exports.convertLength = convertLength;
  /**
   * Converts a area to the requested unit.
   * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches
   * @param {number} area to be converted
   * @param {Units} [originalUnit="meters"] of the distance
   * @param {Units} [finalUnit="kilometers"] returned unit
   * @returns {number} the converted distance
   */
  function convertArea(area, originalUnit, finalUnit) {
      if (originalUnit === void 0) { originalUnit = "meters"; }
      if (finalUnit === void 0) { finalUnit = "kilometers"; }
      if (!(area >= 0)) {
          throw new Error("area must be a positive number");
      }
      var startFactor = exports.areaFactors[originalUnit];
      if (!startFactor) {
          throw new Error("invalid original units");
      }
      var finalFactor = exports.areaFactors[finalUnit];
      if (!finalFactor) {
          throw new Error("invalid final units");
      }
      return (area / startFactor) * finalFactor;
  }
  exports.convertArea = convertArea;
  /**
   * isNumber
   *
   * @param {*} num Number to validate
   * @returns {boolean} true/false
   * @example
   * turf.isNumber(123)
   * //=true
   * turf.isNumber('foo')
   * //=false
   */
  function isNumber(num) {
      return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\s*$/.test(num);
  }
  exports.isNumber = isNumber;
  /**
   * isObject
   *
   * @param {*} input variable to validate
   * @returns {boolean} true/false
   * @example
   * turf.isObject({elevation: 10})
   * //=true
   * turf.isObject('foo')
   * //=false
   */
  function isObject(input) {
      return (!!input) && (input.constructor === Object);
  }
  exports.isObject = isObject;
  /**
   * Validate BBox
   *
   * @private
   * @param {Array<number>} bbox BBox to validate
   * @returns {void}
   * @throws Error if BBox is not valid
   * @example
   * validateBBox([-180, -40, 110, 50])
   * //=OK
   * validateBBox([-180, -40])
   * //=Error
   * validateBBox('Foo')
   * //=Error
   * validateBBox(5)
   * //=Error
   * validateBBox(null)
   * //=Error
   * validateBBox(undefined)
   * //=Error
   */
  function validateBBox(bbox) {
      if (!bbox) {
          throw new Error("bbox is required");
      }
      if (!Array.isArray(bbox)) {
          throw new Error("bbox must be an Array");
      }
      if (bbox.length !== 4 && bbox.length !== 6) {
          throw new Error("bbox must be an Array of 4 or 6 numbers");
      }
      bbox.forEach(function (num) {
          if (!isNumber(num)) {
              throw new Error("bbox must only contain numbers");
          }
      });
  }
  exports.validateBBox = validateBBox;
  /**
   * Validate Id
   *
   * @private
   * @param {string|number} id Id to validate
   * @returns {void}
   * @throws Error if Id is not valid
   * @example
   * validateId([-180, -40, 110, 50])
   * //=Error
   * validateId([-180, -40])
   * //=Error
   * validateId('Foo')
   * //=OK
   * validateId(5)
   * //=OK
   * validateId(null)
   * //=Error
   * validateId(undefined)
   * //=Error
   */
  function validateId(id) {
      if (!id) {
          throw new Error("id is required");
      }
      if (["string", "number"].indexOf(typeof id) === -1) {
          throw new Error("id must be a number or a string");
      }
  }
  exports.validateId = validateId;
  // Deprecated methods
  function radians2degrees() {
      throw new Error("method has been renamed to `radiansToDegrees`");
  }
  exports.radians2degrees = radians2degrees;
  function degrees2radians() {
      throw new Error("method has been renamed to `degreesToRadians`");
  }
  exports.degrees2radians = degrees2radians;
  function distanceToDegrees() {
      throw new Error("method has been renamed to `lengthToDegrees`");
  }
  exports.distanceToDegrees = distanceToDegrees;
  function distanceToRadians() {
      throw new Error("method has been renamed to `lengthToRadians`");
  }
  exports.distanceToRadians = distanceToRadians;
  function radiansToDistance() {
      throw new Error("method has been renamed to `radiansToLength`");
  }
  exports.radiansToDistance = radiansToDistance;
  function bearingToAngle() {
      throw new Error("method has been renamed to `bearingToAzimuth`");
  }
  exports.bearingToAngle = bearingToAngle;
  function convertDistance() {
      throw new Error("method has been renamed to `convertLength`");
  }
  exports.convertDistance = convertDistance;
  }(helpers));

  Object.defineProperty(invariant, "__esModule", { value: true });
  var helpers_1 = helpers;
  /**
   * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
   *
   * @name getCoord
   * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
   * @returns {Array<number>} coordinates
   * @example
   * var pt = turf.point([10, 10]);
   *
   * var coord = turf.getCoord(pt);
   * //= [10, 10]
   */
  function getCoord(coord) {
      if (!coord) {
          throw new Error("coord is required");
      }
      if (!Array.isArray(coord)) {
          if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
              return coord.geometry.coordinates;
          }
          if (coord.type === "Point") {
              return coord.coordinates;
          }
      }
      if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
          return coord;
      }
      throw new Error("coord must be GeoJSON Point or an Array of numbers");
  }
  invariant.getCoord = getCoord;
  /**
   * Unwrap coordinates from a Feature, Geometry Object or an Array
   *
   * @name getCoords
   * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
   * @returns {Array<any>} coordinates
   * @example
   * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
   *
   * var coords = turf.getCoords(poly);
   * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
   */
  function getCoords(coords) {
      if (Array.isArray(coords)) {
          return coords;
      }
      // Feature
      if (coords.type === "Feature") {
          if (coords.geometry !== null) {
              return coords.geometry.coordinates;
          }
      }
      else {
          // Geometry
          if (coords.coordinates) {
              return coords.coordinates;
          }
      }
      throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
  }
  invariant.getCoords = getCoords;
  /**
   * Checks if coordinates contains a number
   *
   * @name containsNumber
   * @param {Array<any>} coordinates GeoJSON Coordinates
   * @returns {boolean} true if Array contains a number
   */
  function containsNumber(coordinates) {
      if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {
          return true;
      }
      if (Array.isArray(coordinates[0]) && coordinates[0].length) {
          return containsNumber(coordinates[0]);
      }
      throw new Error("coordinates must only contain numbers");
  }
  invariant.containsNumber = containsNumber;
  /**
   * Enforce expectations about types of GeoJSON objects for Turf.
   *
   * @name geojsonType
   * @param {GeoJSON} value any GeoJSON object
   * @param {string} type expected GeoJSON type
   * @param {string} name name of calling function
   * @throws {Error} if value is not the expected type.
   */
  function geojsonType(value, type, name) {
      if (!type || !name) {
          throw new Error("type and name required");
      }
      if (!value || value.type !== type) {
          throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
      }
  }
  invariant.geojsonType = geojsonType;
  /**
   * Enforce expectations about types of {@link Feature} inputs for Turf.
   * Internally this uses {@link geojsonType} to judge geometry types.
   *
   * @name featureOf
   * @param {Feature} feature a feature with an expected geometry type
   * @param {string} type expected GeoJSON type
   * @param {string} name name of calling function
   * @throws {Error} error if value is not the expected type.
   */
  function featureOf(feature, type, name) {
      if (!feature) {
          throw new Error("No feature passed");
      }
      if (!name) {
          throw new Error(".featureOf() requires a name");
      }
      if (!feature || feature.type !== "Feature" || !feature.geometry) {
          throw new Error("Invalid input to " + name + ", Feature with geometry required");
      }
      if (!feature.geometry || feature.geometry.type !== type) {
          throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
      }
  }
  invariant.featureOf = featureOf;
  /**
   * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
   * Internally this uses {@link geojsonType} to judge geometry types.
   *
   * @name collectionOf
   * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
   * @param {string} type expected GeoJSON type
   * @param {string} name name of calling function
   * @throws {Error} if value is not the expected type.
   */
  function collectionOf(featureCollection, type, name) {
      if (!featureCollection) {
          throw new Error("No featureCollection passed");
      }
      if (!name) {
          throw new Error(".collectionOf() requires a name");
      }
      if (!featureCollection || featureCollection.type !== "FeatureCollection") {
          throw new Error("Invalid input to " + name + ", FeatureCollection required");
      }
      for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
          var feature = _a[_i];
          if (!feature || feature.type !== "Feature" || !feature.geometry) {
              throw new Error("Invalid input to " + name + ", Feature with geometry required");
          }
          if (!feature.geometry || feature.geometry.type !== type) {
              throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
          }
      }
  }
  invariant.collectionOf = collectionOf;
  /**
   * Get Geometry from Feature or Geometry Object
   *
   * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
   * @returns {Geometry|null} GeoJSON Geometry Object
   * @throws {Error} if geojson is not a Feature or Geometry Object
   * @example
   * var point = {
   *   "type": "Feature",
   *   "properties": {},
   *   "geometry": {
   *     "type": "Point",
   *     "coordinates": [110, 40]
   *   }
   * }
   * var geom = turf.getGeom(point)
   * //={"type": "Point", "coordinates": [110, 40]}
   */
  function getGeom(geojson) {
      if (geojson.type === "Feature") {
          return geojson.geometry;
      }
      return geojson;
  }
  invariant.getGeom = getGeom;
  /**
   * Get GeoJSON object's type, Geometry type is prioritize.
   *
   * @param {GeoJSON} geojson GeoJSON object
   * @param {string} [name="geojson"] name of the variable to display in error message
   * @returns {string} GeoJSON type
   * @example
   * var point = {
   *   "type": "Feature",
   *   "properties": {},
   *   "geometry": {
   *     "type": "Point",
   *     "coordinates": [110, 40]
   *   }
   * }
   * var geom = turf.getType(point)
   * //="Point"
   */
  function getType(geojson, name) {
      if (geojson.type === "FeatureCollection") {
          return "FeatureCollection";
      }
      if (geojson.type === "GeometryCollection") {
          return "GeometryCollection";
      }
      if (geojson.type === "Feature" && geojson.geometry !== null) {
          return geojson.geometry.type;
      }
      return geojson.type;
  }
  invariant.getType = getType;

  Object.defineProperty(booleanPointInPolygon$1, "__esModule", { value: true });
  var invariant_1 = invariant;
  // http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
  // modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
  // which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
  /**
   * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point
   * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.
   *
   * @name booleanPointInPolygon
   * @param {Coord} point input point
   * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
   * @param {Object} [options={}] Optional parameters
   * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if
   * the point is inside the polygon otherwise false.
   * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
   * @example
   * var pt = turf.point([-77, 44]);
   * var poly = turf.polygon([[
   *   [-81, 41],
   *   [-81, 47],
   *   [-72, 47],
   *   [-72, 41],
   *   [-81, 41]
   * ]]);
   *
   * turf.booleanPointInPolygon(pt, poly);
   * //= true
   */
  function booleanPointInPolygon(point, polygon, options) {
      if (options === void 0) { options = {}; }
      // validation
      if (!point) {
          throw new Error("point is required");
      }
      if (!polygon) {
          throw new Error("polygon is required");
      }
      var pt = invariant_1.getCoord(point);
      var geom = invariant_1.getGeom(polygon);
      var type = geom.type;
      var bbox = polygon.bbox;
      var polys = geom.coordinates;
      // Quick elimination if point is not inside bbox
      if (bbox && inBBox(pt, bbox) === false) {
          return false;
      }
      // normalize to multipolygon
      if (type === "Polygon") {
          polys = [polys];
      }
      var insidePoly = false;
      for (var i = 0; i < polys.length && !insidePoly; i++) {
          // check if it is in the outer ring first
          if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
              var inHole = false;
              var k = 1;
              // check for the point in any of the holes
              while (k < polys[i].length && !inHole) {
                  if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
                      inHole = true;
                  }
                  k++;
              }
              if (!inHole) {
                  insidePoly = true;
              }
          }
      }
      return insidePoly;
  }
  var _default = booleanPointInPolygon$1.default = booleanPointInPolygon;
  /**
   * inRing
   *
   * @private
   * @param {Array<number>} pt [x,y]
   * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
   * @param {boolean} ignoreBoundary ignoreBoundary
   * @returns {boolean} inRing
   */
  function inRing(pt, ring, ignoreBoundary) {
      var isInside = false;
      if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
          ring = ring.slice(0, ring.length - 1);
      }
      for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          var xi = ring[i][0];
          var yi = ring[i][1];
          var xj = ring[j][0];
          var yj = ring[j][1];
          var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&
              ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);
          if (onBoundary) {
              return !ignoreBoundary;
          }
          var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&
              (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);
          if (intersect) {
              isInside = !isInside;
          }
      }
      return isInside;
  }
  /**
   * inBBox
   *
   * @private
   * @param {Position} pt point [x,y]
   * @param {BBox} bbox BBox [west, south, east, north]
   * @returns {boolean} true/false if point is inside BBox
   */
  function inBBox(pt, bbox) {
      return bbox[0] <= pt[0] &&
          bbox[1] <= pt[1] &&
          bbox[2] >= pt[0] &&
          bbox[3] >= pt[1];
  }

  function initSelector(size, map) {
    // This closure just stores the tile size and a link to the map

    return function(mapX, mapY, threshold, source, layer) {
      // Get the tile at the [mapX, mapY] position, along with the
      // x/y projected to tile coordinates
      var box = map.getTilePos([mapX, mapY]);
      if (!box) return;

      // Get a link to the features from the requested layer
      var layers = box.tile.sources[source];
      if (!layers) return;
      // TODO: Make sure it's a vector source?
      var data = layers[layer];
      if (!data || data.features.length < 1) return;
      var features = data.features;

      // Get type of features in data. ASSUMES all same type
      var type = features[0].geometry.type;

      var feature;
      switch (type) {
        case "Point":
          // Scale the threshold by frac to make it a displayed distance
          // rather than a distance in local tile coordinates
          feature = findNearest(box.x, box.y, threshold * box.frac, features);
          break;
        case "Polygon":
        case "MultiPolygon":
          var pt = [box.x, box.y];
          feature = features.find(poly => _default(pt, poly));
          break;
        default:
          return; // Unknown feature type!
      }

      if (!feature) return; // No actual feature selected

      // Make a deep copy of the feature (not just a link to the original)
      feature = JSON.parse(JSON.stringify(feature));

      if (type === "Point") {
        // Transform the feature coordinates from tile coordinates back to 
        //  global map coordinates.  TODO: Make this work for Polygons?
        var coords = feature.geometry.coordinates;
        var numTiles = 2 ** box.tile.z;
        coords[0] = (box.tile.x + coords[0] / size) / numTiles;
        coords[1] = (box.tile.y + coords[1] / size) / numTiles;
      }

      return feature;
    }
  }

  function findNearest(x, y, threshold, features) {
    var minDistance = Infinity;
    var minIndex = 0;

    features.forEach(checkDistance);

    function checkDistance(feature, index) {
      var p = feature.geometry.coordinates;
      var distance = Math.sqrt( (p[0] - x)**2 + (p[1] - y)**2 );
      if (distance < minDistance) {
        minDistance = distance;
        minIndex = index;
      }
    }

    if (minDistance > threshold) return;
    return features[minIndex];
  }

  function main() {
    // Get the map container div
    const mapDiv = document.getElementById("map");

    // Setup 2D map
    const factory = init$2({
      size: params.tileSize,
      style: params.style,
      token: params.token,
    });
    const cache = initCache(params.tileSize, factory);
    params.getTile = cache.retrieve;
    params.context = document.getElementById("rasterCanvas").getContext("2d");
    const map = init(params);

    // Set up mouse tracking
    initTouch(mapDiv);

    // Setup panning controls
    var up = document.getElementById("up");
    up.addEventListener("click", function(click) { map.move(0, 0, -1); }, false);
    var down = document.getElementById("down");
    down.addEventListener("click", function(click) { map.move(0, 0, 1); }, false);
    var left = document.getElementById("left");
    left.addEventListener("click", function(click) { map.move(0, -1, 0); }, false);
    var right = document.getElementById("right");
    right.addEventListener("click", function(click) { map.move(0, 1, 0); }, false);

    // Setup zoom controls
    var zoomIn = document.getElementById("zoomIn");
    zoomIn.addEventListener("click", function(click) { map.move(1, 0, 0); }, false);
    var zoomOut = document.getElementById("zoomOut");
    zoomOut.addEventListener("click", function(click) { map.move(-1, 0, 0); }, false);

    // Track loading status and cursor position
    document.getElementById("completion");
    document.getElementById("tooltip");

    // Set up toggle for Burwell polygon visibility
    var burwellVisibility = true;
    var burwellLayers = [];
    factory.promise.then(api => {
      burwellLayers = api.style.layers
        .filter(layer => layer.source === "burwell")
        .map(l => l.id);
    });
    var toggleBurwell = document.getElementById("toggleBurwell");
    toggleBurwell.addEventListener("click", function(click) {
      burwellVisibility = !burwellVisibility;
      setVisibility(burwellLayers, burwellVisibility);
      map.reset();
    }, false);

    function setVisibility(layers, visibility) {
      const setter = (visibility)
        ? factory.showLayer
        : factory.hideLayer;
      layers.forEach( layer => setter(layer) );
      cache.process( tile => { tile.rendered = false; } );
    }

    // Get ready to print out feature info
    initSelector(params.tileSize, map);
    document.getElementById("info");

    // Start animation loop
    requestAnimationFrame(checkRender);
    function checkRender(time) {
      map.drawTiles();
      cache.trim(map.tileDistance, 1.5);
      factory.sortTasks(cache.getPriority);

      // Report loading status
  //    var percent = map.loaded() * 100;
  //    loaded.innerHTML = (percent < 100)
  //      ? "Loading: " + percent.toFixed(0) + "%"
  //      : "Complete! 100%";
  //
  //    // Find the well nearest to the cursor
  //    var box = mapDiv.getBoundingClientRect();
  //    var x = cursor.x() - box.left;
  //    var y = cursor.y() - box.top;
  //    var selected = selector(x, y, 5, "burwell", "burwell_fill");
  //
  //    info.innerHTML = "Tiles in cache: " + numTiles + "<br>";
  //
  //    info.innerHTML += (selected && selected.properties)
  //      ? "<pre>" + JSON.stringify(selected.properties, null, 2) + "</pre>"
  //      : "";

      requestAnimationFrame(checkRender);
    }
  }

  exports.main = main;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
